module RouterHOF

using HTTP

using ..Middleware: genkey
using ..AppContext: Context, Documenation
using ..Types: TaggedRoute, TaskDefinition, CronDefinition, Nullable

export router

"""
This functions assists registering routes with a specific prefix.
You can optionally assign tags either at the prefix and/or route level which
are used to group and organize the autogenerated documentation
"""
function router(ctx::Context, prefix::String="";
    tags::Vector{String}=Vector{String}(),
    middleware::Nullable{Vector}=nothing,
    interval::Nullable{Real}=nothing,
    cron::Nullable{String}=nothing)

    return createrouter(ctx, prefix, tags, middleware, interval, cron)
end

function createrouter(ctx::Context, prefix::String,
    routertags::Vector{String},
    routermiddleware::Nullable{Vector},
    routerinterval::Nullable{Real},
    routercron::Nullable{String}=nothing)

    # appends a "/" character to the given string if doesn't have one. 
    function fixpath(path::String)
        path = String(strip(path))
        if !isnothing(path) && !isempty(path) && path !== "/"
            return startswith(path, "/") ? path : "/$path"
        end
        return ""
    end

    # This function takes input from the user next to the request handler
    return function (path=nothing;
        tags::Vector{String}=Vector{String}(),
        middleware::Nullable{Vector}=nothing,
        interval::Nullable{Real}=routerinterval,
        cron::Nullable{String}=routercron)

        # this is called inside the @register macro (only it knows the exact httpmethod associated with each path)
        return function (httpmethod::String)

            """
            This scenario can happen when the user passes a router object directly like so: 

            @get router("/math/power/{a}/{b}") function (req::HTTP.Request, a::Float64, b::Float64)
                return a ^ b
            end

            Under normal circumstances, the function returned by the router call is used when registering routes. 
            However, in this specific case, the call to router returns a higher-order function (HOF) that's nested one 
            layer deeper than expected.

            Due to the way we call these functions to derive the path for the currently registered route, 
            the path argument can sometimes be mistakenly set to the HTTP method (e.g., "GET", "POST"). 
            This can lead to the path getting concatenated with the HTTP method string.

            To account for this specific use case, we've added a check in the inner function to verify whether 
            path matches the current passed in httpmethod. If it does, we assume that path has been incorrectly 
            set to the HTTP method, and we update path to use the router prefix instead.
            """
            if path === httpmethod
                path = prefix
            else
                # combine the current routers prefix with this specfic path 
                path = !isnothing(path) ? "$(fixpath(prefix))$(fixpath(path))" : fixpath(prefix)
            end

            if !(isnothing(routermiddleware) && isnothing(middleware))
                # add both router & route-sepecific middleware
                ctx.service.custommiddleware[genkey(httpmethod, path)] = (routermiddleware, middleware)
            end

            # register interval for this route 
            if !isnothing(interval) && interval >= 0.0
                task = TaskDefinition(path, httpmethod, interval)
                push!(ctx.tasks.task_definitions, task)
            end

            # register cron expression for this route 
            if !isnothing(cron) && !isempty(cron)
                job = CronDefinition(path, httpmethod, cron)
                push!(ctx.cron.job_definitions, job)
            end

            combinedtags = [tags..., routertags...]

            # register tags
            if !haskey(ctx.docs.taggedroutes, path)
                ctx.docs.taggedroutes[path] = TaggedRoute([httpmethod], combinedtags)
            else
                combinedmethods = vcat(httpmethod, ctx.docs.taggedroutes[path].httpmethods)
                ctx.docs.taggedroutes[path] = TaggedRoute(combinedmethods, combinedtags)
            end

            #return path 
            return path
        end
    end
end


end