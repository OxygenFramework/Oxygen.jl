<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · Oxygen.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Oxygen.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#About"><span>About</span></a></li><li><a class="tocitem" href="#Contact"><span>Contact</span></a></li><li><a class="tocitem" href="#Features"><span>Features</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Minimalistic-Example"><span>Minimalistic Example</span></a></li><li><a class="tocitem" href="#Handlers"><span>Handlers</span></a></li><li><a class="tocitem" href="#Routing-Macro-and-Function-Syntax"><span>Routing Macro &amp; Function Syntax</span></a></li><li><a class="tocitem" href="#Render-Functions"><span>Render Functions</span></a></li><li><a class="tocitem" href="#Path-parameters"><span>Path parameters</span></a></li><li><a class="tocitem" href="#Query-parameters"><span>Query parameters</span></a></li><li><a class="tocitem" href="#HTML-Forms"><span>HTML Forms</span></a></li><li><a class="tocitem" href="#Return-JSON"><span>Return JSON</span></a></li><li><a class="tocitem" href="#Deserialize-and-Serialize-custom-structs"><span>Deserialize &amp; Serialize custom structs</span></a></li><li><a class="tocitem" href="#Extractors"><span>Extractors</span></a></li><li><a class="tocitem" href="#Application-Context"><span>Application Context</span></a></li><li><a class="tocitem" href="#Interpolating-variables-into-endpoints"><span>Interpolating variables into endpoints</span></a></li><li><a class="tocitem" href="#Routers"><span>Routers</span></a></li><li><a class="tocitem" href="#Cron-Scheduling"><span>Cron Scheduling</span></a></li><li><a class="tocitem" href="#Repeat-Tasks"><span>Repeat Tasks</span></a></li><li><a class="tocitem" href="#Hot-reloads-with-Revise"><span>Hot reloads with Revise</span></a></li><li><a class="tocitem" href="#Multiple-Instances"><span>Multiple Instances</span></a></li><li><a class="tocitem" href="#Multithreading-and-Parallelism"><span>Multithreading &amp; Parallelism</span></a></li><li><a class="tocitem" href="#Protocol-Buffers"><span>Protocol Buffers</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Templating"><span>Templating</span></a></li><li><a class="tocitem" href="#Mounting-Static-Files"><span>Mounting Static Files</span></a></li><li><a class="tocitem" href="#Mounting-Dynamic-Files"><span>Mounting Dynamic Files</span></a></li><li><a class="tocitem" href="#Performance-Tips"><span>Performance Tips</span></a></li><li><a class="tocitem" href="#Logging"><span>Logging</span></a></li><li><a class="tocitem" href="#Middleware"><span>Middleware</span></a></li><li><a class="tocitem" href="#Custom-Response-Serializers"><span>Custom Response Serializers</span></a></li><li><a class="tocitem" href="#Autogenerated-Docs-with-Swagger"><span>Autogenerated Docs with Swagger</span></a></li><li class="toplevel"><a class="tocitem" href="#API-Reference-(macros)"><span>API Reference (macros)</span></a></li></ul></li><li><a class="tocitem" href="api/">Api</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="tutorial/first_steps/">First Steps</a></li><li><a class="tocitem" href="tutorial/request_types/">Request Types</a></li><li><a class="tocitem" href="tutorial/path_parameters/">Path Parameters</a></li><li><a class="tocitem" href="tutorial/query_parameters/">Query Parameters</a></li><li><a class="tocitem" href="tutorial/request_body/">Request Body</a></li><li><a class="tocitem" href="tutorial/cron_scheduling/">Cron Scheduling</a></li><li><a class="tocitem" href="tutorial/bigger_applications/">Bigger Applications - Multiple Files</a></li><li><a class="tocitem" href="tutorial/oauth2/">OAuth2 with Umbrella.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/OxygenFramework/Oxygen.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Oxygen.jl"><a class="docs-heading-anchor" href="#Oxygen.jl">Oxygen.jl</a><a id="Oxygen.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Oxygen.jl" title="Permalink"></a></h1><div>
  </br>
  <p align="center"><img src="oxygen.png" width="20%"></p>
  <p align="center">
    <strong>A breath of fresh air for programming web apps in Julia.</strong>
  </p>
  <p align="center">
    <a href='https://juliahub.com/ui/Packages/General/Oxygen'><img src='https://juliahub.com/docs/General/Oxygen/stable/version.svg' alt='Version' /></a>
    <a href='https://oxygenframework.github.io/Oxygen.jl/stable/'><img src='https://img.shields.io/badge/docs-stable-blue.svg' alt='documentation stable' /></a>
    <a href='https://github.com/OxygenFramework/Oxygen.jl/actions/workflows/ci.yml'><img src='https://github.com/OxygenFramework/Oxygen.jl/actions/workflows/ci.yml/badge.svg' alt='Build Status' /></a>
    <a href='https://coveralls.io/github/OxygenFramework/Oxygen.jl?branch=master'><img src='https://coveralls.io/repos/github/OxygenFramework/Oxygen.jl/badge.svg?branch=master' alt='Coverage Status' /></a>
    <!-- <a href='https://codecov.io/gh/OxygenFramework/Oxygen.jl'><img src='https://codecov.io/gh/OxygenFramework/Oxygen.jl/branch/master/graph/badge.svg' alt='Coverage Status' /></a> -->
  </p>
</div><h2 id="About"><a class="docs-heading-anchor" href="#About">About</a><a id="About-1"></a><a class="docs-heading-anchor-permalink" href="#About" title="Permalink"></a></h2><p>Oxygen is a micro-framework built on top of the HTTP.jl library.  Breathe easy knowing you can quickly spin up a web server with abstractions you&#39;re already familiar with.</p><h2 id="Contact"><a class="docs-heading-anchor" href="#Contact">Contact</a><a id="Contact-1"></a><a class="docs-heading-anchor-permalink" href="#Contact" title="Permalink"></a></h2><p>Need Help? Feel free to reach out on our social media channels.</p><p><a href="https://discord.gg/g5dmzRkdAR"><img src="https://img.shields.io/badge/chat-Discord-7289DA?logo=discord" alt="Chat on Discord"/></a>  <a href="https://github.com/OxygenFramework/Oxygen.jl/discussions"><img src="https://img.shields.io/badge/discussions-GitHub-333333?logo=github" alt="Discuss on GitHub"/></a></p><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><ul><li>Straightforward routing</li><li>Real-time Metrics Dashboard</li><li>Auto-generated swagger documentation</li><li>Out-of-the-box JSON serialization &amp; deserialization (customizable)</li><li>Type definition support for path parameters</li><li>Request Extractors</li><li>Application Context</li><li>Multiple Instance Support</li><li>Multithreading support</li><li>Websockets, Streaming, and Server-Sent Events</li><li>Cron Scheduling (on endpoints &amp; functions)</li><li>Middleware chaining (at the application, router, and route levels)</li><li>Static &amp; Dynamic file hosting</li><li>Hot reloads with Revise.jl</li><li>Templating Support</li><li>Plotting Support</li><li>Protocol Buffer Support</li><li>Route tagging</li><li>Repeat tasks</li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language-julia hljs">pkg&gt; add Oxygen</code></pre><h2 id="Minimalistic-Example"><a class="docs-heading-anchor" href="#Minimalistic-Example">Minimalistic Example</a><a id="Minimalistic-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Minimalistic-Example" title="Permalink"></a></h2><p>Create a web-server with very few lines of code</p><pre><code class="language-julia hljs">using Oxygen
using HTTP

@get &quot;/greet&quot; function(req::HTTP.Request)
    return &quot;hello world!&quot;
end

# start the web server
serve()</code></pre><h2 id="Handlers"><a class="docs-heading-anchor" href="#Handlers">Handlers</a><a id="Handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Handlers" title="Permalink"></a></h2><p>Handlers are used to connect your code to the server in a clean &amp; straightforward way.  They assign a url to a function and invoke the function when an incoming request matches that url.</p><ul><li>Handlers can be imported from other modules and distributed across multiple files for better organization and modularity</li><li>All handlers have equivalent macro &amp; function implementations and support <code>do..end</code> block syntax</li><li>The type of first argument is used to identify what kind of handler is being registered</li><li>This package assumes it&#39;s a <code>Request</code> handler by default when no type information is provided</li></ul><p>There are 3 types of supported handlers:</p><ul><li><code>Request</code> Handlers</li><li><code>Stream</code> Handlers</li><li><code>Websocket</code> Handlers</li></ul><pre><code class="language-julia hljs">using HTTP
using Oxygen

# Request Handler
@get &quot;/&quot; function(req::HTTP.Request)
    ...
end

# Stream Handler
@stream &quot;/stream&quot; function(stream::HTTP.Stream)
    ...
end

# Websocket Handler
@websocket &quot;/ws&quot; function(ws::HTTP.WebSocket)
    ...
end</code></pre><p>They are just functions which means there are many ways that they can be expressed and defined. Below is an example of several different ways you can express and assign a <code>Request</code> handler.</p><pre><code class="language-julia hljs">@get &quot;/greet&quot; function()
    &quot;hello world!&quot;
end

@get(&quot;/gruessen&quot;) do 
    &quot;Hallo Welt!&quot;
end

@get &quot;/saluer&quot; () -&gt; begin
    &quot;Bonjour le monde!&quot;
end

@get &quot;/saludar&quot; () -&gt; &quot;¡Hola Mundo!&quot;
@get &quot;/salutare&quot; f() = &quot;ciao mondo!&quot;

# This function can be declared in another module
function subtract(req, a::Float64, b::Float64)
  return a - b
end

# register foreign request handlers like this
@get &quot;/subtract/{a}/{b}&quot; subtract</code></pre><p>&lt;details&gt;     &lt;summary&gt;&lt;b&gt;More Handler Docs&lt;/b&gt;&lt;/summary&gt;</p><h3 id="Request-Handlers"><a class="docs-heading-anchor" href="#Request-Handlers">Request Handlers</a><a id="Request-Handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Request-Handlers" title="Permalink"></a></h3><p>Request handlers are used to handle HTTP requests. They are defined using macros or their function equivalents, and accept a <code>HTTP.Request</code> object as the first argument. These handlers support both function and do-block syntax.</p><ul><li>The default Handler when no type information is provided</li><li>Routing Macros: <code>@get</code>, <code>@post</code>, <code>@put</code>, <code>@patch</code>, <code>@delete</code>, <code>@route</code></li><li>Routing Functions: <code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code>, <code>route()</code></li></ul><h3 id="Stream-Handlers"><a class="docs-heading-anchor" href="#Stream-Handlers">Stream Handlers</a><a id="Stream-Handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Stream-Handlers" title="Permalink"></a></h3><p>Stream handlers are used to stream data. They are defined using the <code>@stream</code> macro or the <code>stream()</code> function and accept a <code>HTTP.Stream</code> object as the first argument. These handlers support both function and do-block syntax.</p><ul><li><code>@stream</code> and <code>stream()</code> don&#39;t require a type definition on the first argument, they assume it&#39;s a stream.</li><li><code>Stream</code> handlers can be assigned with standard routing macros &amp; functions: <code>@get</code>, <code>@post</code>, etc</li><li>You need to explicitly include the type definition so Oxygen can identify this as a <code>Stream</code> handler</li></ul><h3 id="Websocket-Handlers"><a class="docs-heading-anchor" href="#Websocket-Handlers">Websocket Handlers</a><a id="Websocket-Handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Websocket-Handlers" title="Permalink"></a></h3><p>Websocket handlers are used to handle websocket connections. They are defined using the <code>@websocket</code> macro or the <code>websocket()</code> function and accept a <code>HTTP.WebSocket</code> object as the first argument. These handlers support both function and do-block syntax.</p><ul><li><code>@websocket</code> and <code>websocket()</code> don&#39;t require a type definition on the first argument, they assume it&#39;s a websocket.</li><li><code>Websocket</code> handlers can also be assigned with the <code>@get</code> macro or <code>get()</code> function, because the websocket protocol requires a <code>GET</code> request to initiate the handshake. </li><li>You need to explicitly include the type definition so Oxygen can identify this as a <code>Websocket</code> handler</li></ul><p>&lt;/details&gt;</p><h2 id="Routing-Macro-and-Function-Syntax"><a class="docs-heading-anchor" href="#Routing-Macro-and-Function-Syntax">Routing Macro &amp; Function Syntax</a><a id="Routing-Macro-and-Function-Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Routing-Macro-and-Function-Syntax" title="Permalink"></a></h2><p>There are two primary ways to register your request handlers: the standard routing macros or the routing functions which utilize the do-block syntax. </p><p>For each routing macro, we now have a an equivalent routing function</p><pre><code class="language-julia hljs">@get    -&gt; get()
@post   -&gt; post()
@put    -&gt; put()
@patch  -&gt; patch()
@delete -&gt; delete()
@route  -&gt; route()</code></pre><p>The only practical difference between the two is that the routing macros are called during the precompilation stage, whereas the routing functions are only called when invoked. (The routing macros call the routing functions under the hood)</p><pre><code class="language-julia hljs"># Routing Macro syntax
@get &quot;/add/{x}/{y}&quot; function(request::HTTP.Request, x::Int, y::Int)
    x + y
end

# Routing Function syntax
get(&quot;/add/{x}/{y}&quot;) do request::HTTP.Request, x::Int, y::Int
    x + y
end</code></pre><h2 id="Render-Functions"><a class="docs-heading-anchor" href="#Render-Functions">Render Functions</a><a id="Render-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Render-Functions" title="Permalink"></a></h2><p>Oxygen, by default, automatically identifies the Content-Type of the return value from a request handler when building a Response. This default functionality is quite useful, but it does have an impact on performance. In situations where the return type is known, It&#39;s recommended to use one of the pre-existing render functions to speed things up.</p><p>Here&#39;s a list of the currently supported render functions: <code>html</code>, <code>text</code>, <code>json</code>, <code>file</code>, <code>xml</code>, <code>js</code>, <code>css</code>, <code>binary</code></p><p>Below is an example of how to use these functions:</p><pre><code class="language-julia hljs">using Oxygen 

get(&quot;/html&quot;) do 
    html(&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;)
end

get(&quot;/text&quot;) do 
    text(&quot;Hello World&quot;)
end

get(&quot;/json&quot;) do 
    json(Dict(&quot;message&quot; =&gt; &quot;Hello World&quot;))
end

serve()</code></pre><p>In most cases, these functions accept plain strings as inputs. The only exceptions are the <code>binary</code> function, which accepts a <code>Vector{UInt8}</code>, and the <code>json</code> function which accepts any serializable type. </p><ul><li>Each render function accepts a status and custom headers.</li><li>The Content-Type and Content-Length headers are automatically set by these render functions</li></ul><h2 id="Path-parameters"><a class="docs-heading-anchor" href="#Path-parameters">Path parameters</a><a id="Path-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Path-parameters" title="Permalink"></a></h2><p>Path parameters are declared with braces and are passed directly to your request handler. </p><pre><code class="language-julia hljs">using Oxygen

# use path params without type definitions (defaults to Strings)
@get &quot;/add/{a}/{b}&quot; function(req, a, b)
    return parse(Float64, a) + parse(Float64, b)
end

# use path params with type definitions (they are automatically converted)
@get &quot;/multiply/{a}/{b}&quot; function(req, a::Float64, b::Float64)
    return a * b
end

# The order of the parameters doesn&#39;t matter (just the name matters)
@get &quot;/subtract/{a}/{b}&quot; function(req, b::Int64, a::Int64)
    return a - b
end

# start the web server
serve()</code></pre><h2 id="Query-parameters"><a class="docs-heading-anchor" href="#Query-parameters">Query parameters</a><a id="Query-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Query-parameters" title="Permalink"></a></h2><p>Query parameters can be declared directly inside of your handlers signature. Any parameter that isn&#39;t mentioned inside the route path is assumed to be a query parameter.</p><ul><li>If a default value is not provided, it&#39;s assumed to be a required parameter</li></ul><pre><code class="language-julia hljs">@get &quot;/query&quot; function(req::HTTP.Request, a::Int, message::String=&quot;hello world&quot;)
    return (a, message)
end</code></pre><p>Alternatively, you can use the <code>queryparams()</code> function to extract the raw values from the url as a dictionary. </p><pre><code class="language-julia hljs">@get &quot;/query&quot; function(req::HTTP.Request)
    return queryparams(req)
end</code></pre><h2 id="HTML-Forms"><a class="docs-heading-anchor" href="#HTML-Forms">HTML Forms</a><a id="HTML-Forms-1"></a><a class="docs-heading-anchor-permalink" href="#HTML-Forms" title="Permalink"></a></h2><p>Use the <code>formdata()</code> function to extract and parse the form data from the body of a request. This function returns a dictionary of key-value pairs from the form</p><pre><code class="language-julia hljs">using Oxygen

# Setup a basic form
@get &quot;/&quot; function()
    html(&quot;&quot;&quot;
    &lt;form action=&quot;/form&quot; method=&quot;post&quot;&gt;
        &lt;label for=&quot;firstname&quot;&gt;First name:&lt;/label&gt;&lt;br&gt;
        &lt;input type=&quot;text&quot; id=&quot;firstname&quot; name=&quot;firstname&quot;&gt;&lt;br&gt;
        &lt;label for=&quot;lastname&quot;&gt;Last name:&lt;/label&gt;&lt;br&gt;
        &lt;input type=&quot;text&quot; id=&quot;lastname&quot; name=&quot;lastname&quot;&gt;&lt;br&gt;&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
    &lt;/form&gt;
    &quot;&quot;&quot;)
end

# Parse the form data and return it
@post &quot;/form&quot; function(req)
    data = formdata(req)
    return data
end

serve()</code></pre><h2 id="Return-JSON"><a class="docs-heading-anchor" href="#Return-JSON">Return JSON</a><a id="Return-JSON-1"></a><a class="docs-heading-anchor-permalink" href="#Return-JSON" title="Permalink"></a></h2><p>All objects are automatically deserialized into JSON using the JSON3 library</p><pre><code class="language-julia hljs">using Oxygen
using HTTP

@get &quot;/data&quot; function(req::HTTP.Request)
    return Dict(&quot;message&quot; =&gt; &quot;hello!&quot;, &quot;value&quot; =&gt; 99.3)
end

# start the web server
serve()</code></pre><h2 id="Deserialize-and-Serialize-custom-structs"><a class="docs-heading-anchor" href="#Deserialize-and-Serialize-custom-structs">Deserialize &amp; Serialize custom structs</a><a id="Deserialize-and-Serialize-custom-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Deserialize-and-Serialize-custom-structs" title="Permalink"></a></h2><p>Oxygen provides some out-of-the-box serialization &amp; deserialization for most objects but requires the use of StructTypes when converting structs</p><pre><code class="language-julia hljs">using Oxygen
using HTTP
using StructTypes

struct Animal
    id::Int
    type::String
    name::String
end

# Add a supporting struct type definition so JSON3 can serialize &amp; deserialize automatically
StructTypes.StructType(::Type{Animal}) = StructTypes.Struct()

@get &quot;/get&quot; function(req::HTTP.Request)
    # serialize struct into JSON automatically (because we used StructTypes)
    return Animal(1, &quot;cat&quot;, &quot;whiskers&quot;)
end

@post &quot;/echo&quot; function(req::HTTP.Request)
    # deserialize JSON from the request body into an Animal struct
    animal = json(req, Animal)
    # serialize struct back into JSON automatically (because we used StructTypes)
    return animal
end

# start the web server
serve()</code></pre><h2 id="Extractors"><a class="docs-heading-anchor" href="#Extractors">Extractors</a><a id="Extractors-1"></a><a class="docs-heading-anchor-permalink" href="#Extractors" title="Permalink"></a></h2><p>Oxygen comes with several built-in extractors designed to reduce the amount of boilerplate required to serialize inputs to your handler functions. By simply defining a struct and specifying the data source, these extractors streamline the process of data ingestion &amp; validation through a uniform api.</p><ul><li>The serialized data is accessible through the <code>payload</code> property</li><li>Can be used alongside other parameters and extractors</li><li>Default values can be assigned when defined with the <code>@kwdef</code> macro</li><li>Includes both global and local validators</li><li>Struct definitions can be deeply nested</li></ul><p>Supported Extractors:</p><ul><li><code>Path</code> - extracts from path parameters</li><li><code>Query</code> - extracts from query parameters, </li><li><code>Header</code> - extracts from request headers</li><li><code>Form</code> - extracts form data from the request body</li><li><code>Body</code> - serializes the entire request body to a given type (String, Float64, etc..)</li><li><code>ProtoBuffer</code> - extracts the <code>ProtoBuf</code> message from the request body (available through a package extension)</li><li><code>Json</code> - extracts json from the request body</li><li><code>JsonFragment</code> - extracts a &quot;fragment&quot; of the json body using the parameter name to identify and extract the corresponding top-level key</li></ul><h4 id="Using-Extractors-and-Parameters"><a class="docs-heading-anchor" href="#Using-Extractors-and-Parameters">Using Extractors &amp; Parameters</a><a id="Using-Extractors-and-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Extractors-and-Parameters" title="Permalink"></a></h4><p>In this example we show that the <code>Path</code> extractor can be used alongside regular path parameters. This Also works with regular query parameters and the <code>Query</code> extractor.</p><pre><code class="language-julia hljs">struct Add
    b::Int
    c::Int
end

@get &quot;/add/{a}/{b}/{c}&quot; function(req, a::Int, pathparams::Path{Add})
    add = pathparams.payload # access the serialized payload
    return a + add.b + add.c
end</code></pre><h4 id="Default-Values"><a class="docs-heading-anchor" href="#Default-Values">Default Values</a><a id="Default-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Values" title="Permalink"></a></h4><p>Default values can be setup with structs using the <code>@kwdef</code> macro.</p><pre><code class="language-julia hljs">@kwdef struct Pet
    name::String
    age::Int = 10
end

@post &quot;/pet&quot; function(req, params::Json{Pet})
    return params.payload # access the serialized payload
end</code></pre><h4 id="Validation"><a class="docs-heading-anchor" href="#Validation">Validation</a><a id="Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Validation" title="Permalink"></a></h4><p>On top of serializing incoming data, you can also define your own validation rules by using the <code>validate</code> function. In the example below we show how to use both <code>global</code> and <code>local</code> validators in your code.</p><ul><li>Validators are completely optional</li><li>During the validation phase, oxygen will call the <code>global</code> validator before running a <code>local</code> validator.</li></ul><pre><code class="language-julia hljs">import Oxygen: validate

struct Person
    name::String
    age::Int
end

# Define a global validator 
validate(p::Person) = p.age &gt;= 0

# Only the global validator is ran here
@post &quot;/person&quot; function(req, newperson::Json{Person})
    return newperson.payload
end

# In this case, both global and local validators are ran (this also makes sure the person is age 21+)
# You can also use this sytnax instead: Json(Person, p -&gt; p.age &gt;= 21)
@post &quot;/adult&quot; function(req, newperson = Json{Person}(p -&gt; p.age &gt;= 21))
    return newperson.payload
end</code></pre><h2 id="Application-Context"><a class="docs-heading-anchor" href="#Application-Context">Application Context</a><a id="Application-Context-1"></a><a class="docs-heading-anchor-permalink" href="#Application-Context" title="Permalink"></a></h2><p>Most applications at some point will need to rely on some shared global state across the codebase.  This usually comes in the form of a shared database connection pool or some other in memory store.  Oxygen provides a <code>context</code> argument which acts as a free spot for developers to store any objects that  should be available throughout the lifetime of an application.</p><p>There are three primary ways to get access to your application context</p><ul><li>Injected into any request handler using the <code>Context</code> struct.</li><li>The <code>context</code> keyword argument in a function handler</li><li>Through the <code>context()</code> function </li></ul><p><em>There are no built-in data race protections</em>, but this is intentional. Not all applications have the same requirements,  so it&#39;s up to the developer to decide how to best handle this. For those who need to share mutable state across multiple threads I&#39;d recommend looking into using <code>Actors</code>, <code>Channels</code>, or <code>ReentrantLocks</code> to handle this quickly.</p><p>Below is a simplified example where we store a <code>Person</code> as the application context to show how things are  connected and shared.</p><pre><code class="language-julia hljs">using Oxygen

struct Person
    name::String
end

# The ctx argument here is injected through the Context class
@get &quot;/ctx-injection&quot; function(req, ctx::Context{Person})
    person :: Person = ctx.payload # access the underlying value
    return &quot;Hello $(person.name)!&quot;
end

# Access the context through the &#39;context&#39; keyword argument 
@get &quot;/ctx-kwarg&quot; function(req; context)
    person :: Person = context 
    return &quot;Hello $(person.name)!&quot;
end

# Access context through the &#39;context()&#39; function
@get &quot;/ctx-function&quot; function(req)
    person :: Person = context()
    return &quot;Hello $(person.name)!&quot;
end

# This represents the application context shared between all handlers
person = Person(&quot;John&quot;)

# Here is how we set the application context in our server
serve(context=person)</code></pre><h2 id="Interpolating-variables-into-endpoints"><a class="docs-heading-anchor" href="#Interpolating-variables-into-endpoints">Interpolating variables into endpoints</a><a id="Interpolating-variables-into-endpoints-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolating-variables-into-endpoints" title="Permalink"></a></h2><p>You can interpolate variables directly into the paths, which makes dynamically registering routes a breeze </p><p>(Thanks to @anandijain for the idea)</p><pre><code class="language-julia hljs">using Oxygen

operations = Dict(&quot;add&quot; =&gt; +, &quot;multiply&quot; =&gt; *)
for (pathname, operator) in operations
    @get &quot;/$pathname/{a}/{b}&quot; function (req, a::Float64, b::Float64)
        return operator(a, b)
    end
end

# start the web server
serve()</code></pre><h2 id="Routers"><a class="docs-heading-anchor" href="#Routers">Routers</a><a id="Routers-1"></a><a class="docs-heading-anchor-permalink" href="#Routers" title="Permalink"></a></h2><p>The <code>router()</code> function is an HOF (higher order function) that allows you to reuse the same path prefix &amp; properties across multiple endpoints. This is helpful when your api starts to grow and you want to keep your path operations organized.</p><p>Below are the arguments the <code>router()</code> function can take:</p><pre><code class="language-julia hljs">router(prefix::String; tags::Vector, middleware::Vector, interval::Real, cron::String)</code></pre><ul><li><code>tags</code> - are used to organize endpoints in the autogenerated docs</li><li><code>middleware</code> - is used to setup router &amp; route-specific middleware</li><li><code>interval</code> - is used to support repeat actions (<em>calling a request handler on a set interval in seconds</em>)</li><li><code>cron</code> - is used to specify a cron expression that determines when to call the request handler.</li></ul><pre><code class="language-julia hljs">using Oxygen

# Any routes that use this router will be automatically grouped 
# under the &#39;math&#39; tag in the autogenerated documenation
math = router(&quot;/math&quot;, tags=[&quot;math&quot;])

# You can also assign route specific tags
@get math(&quot;/multiply/{a}/{b}&quot;, tags=[&quot;multiplication&quot;]) function(req, a::Float64, b::Float64)
    return a * b
end

@get math(&quot;/divide/{a}/{b}&quot;) function(req, a::Float64, b::Float64)
    return a / b
end

serve()</code></pre><h2 id="Cron-Scheduling"><a class="docs-heading-anchor" href="#Cron-Scheduling">Cron Scheduling</a><a id="Cron-Scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Cron-Scheduling" title="Permalink"></a></h2><p>Oxygen comes with a built-in cron scheduling system that allows you to call endpoints and functions automatically when the cron expression matches the current time.</p><p>When a job is scheduled, a new task is created and runs in the background. Each task uses its given cron expression and the current time to determine how long it needs to sleep before it can execute.</p><p>The cron parser in Oxygen is based on the same specifications as the one used in Spring. You can find more information about this on the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/support/CronExpression.html">Spring Cron Expressions</a> page.</p><h3 id="Cron-Expression-Syntax"><a class="docs-heading-anchor" href="#Cron-Expression-Syntax">Cron Expression Syntax</a><a id="Cron-Expression-Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Cron-Expression-Syntax" title="Permalink"></a></h3><p>The following is a breakdown of what each parameter in our cron expression represents. While our specification closely resembles the one defined by Spring, it&#39;s not an exact 1-to-1 match.</p><pre><code class="nohighlight hljs">The string has six single space-separated time and date fields:

 ┌───────────── second (0-59)
 │ ┌───────────── minute (0 - 59)
 │ │ ┌───────────── hour (0 - 23)
 │ │ │ ┌───────────── day of the month (1 - 31)
 │ │ │ │ ┌───────────── month (1 - 12) (or JAN-DEC)
 │ │ │ │ │ ┌───────────── day of the week (1 - 7)
 │ │ │ │ │ │          (Monday is 1, Tue is 2... and Sunday is 7)
 │ │ │ │ │ │
 * * * * * *</code></pre><p>Partial expressions are also supported, which means that subsequent expressions can be left out (they are defaulted to <code>&#39;*&#39;</code>). </p><pre><code class="language-julia hljs"># In this example we see only the `seconds` part of the expression is defined. 
# This means that all following expressions are automatically defaulted to &#39;*&#39; expressions
@cron &quot;*/2&quot; function()
    println(&quot;runs every 2 seconds&quot;)
end</code></pre><h3 id="Scheduling-Endpoints"><a class="docs-heading-anchor" href="#Scheduling-Endpoints">Scheduling Endpoints</a><a id="Scheduling-Endpoints-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling-Endpoints" title="Permalink"></a></h3><p>The <code>router()</code> function has a keyword argument called <code>cron</code>, which accepts a cron expression that determines when an endpoint is called. Just like the other keyword arguments, it can be reused by endpoints that share routers or be overridden by inherited endpoints.</p><pre><code class="language-julia hljs"># execute at 8, 9 and 10 o&#39;clock of every day.
@get router(&quot;/cron-example&quot;, cron=&quot;0 0 8-10 * * *&quot;) function(req)
    println(&quot;here&quot;)
end

# execute this endpoint every 5 seconds (whenever current_seconds % 5 == 0)
every5 = router(&quot;/cron&quot;, cron=&quot;*/5&quot;)

# this endpoint inherits the cron expression
@get every5(&quot;/first&quot;) function(req)
    println(&quot;first&quot;)
end

# Now this endpoint executes every 2 seconds ( whenever current_seconds % 2 == 0 ) instead of every 5
@get every5(&quot;/second&quot;, cron=&quot;*/2&quot;) function(req)
    println(&quot;second&quot;)
end</code></pre><h3 id="Scheduling-Functions"><a class="docs-heading-anchor" href="#Scheduling-Functions">Scheduling Functions</a><a id="Scheduling-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling-Functions" title="Permalink"></a></h3><p>In addition to scheduling endpoints, you can also use the new <code>@cron</code> macro to schedule functions. This is useful if you want to run code at specific times without making it visible or callable in the API.</p><pre><code class="language-julia hljs">@cron &quot;*/2&quot; function()
    println(&quot;runs every 2 seconds&quot;)
end

@cron &quot;0 0/30 8-10 * * *&quot; function()
  println(&quot;runs at 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day&quot;)
end</code></pre><h3 id="Starting-and-Stopping-Cron-Jobs"><a class="docs-heading-anchor" href="#Starting-and-Stopping-Cron-Jobs">Starting &amp; Stopping Cron Jobs</a><a id="Starting-and-Stopping-Cron-Jobs-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-and-Stopping-Cron-Jobs" title="Permalink"></a></h3><p>When you run <code>serve()</code> or <code>serveparallel()</code>, all registered cron jobs are automatically started. If the server is stopped or killed, all running jobs will also be terminated. You can stop the server and all repeat tasks and cron jobs by calling the <code>terminate()</code> function or manually killing the server with <code>ctrl+C</code>.</p><p>In addition, Oxygen provides utility functions to manually start and stop cron jobs: <code>startcronjobs()</code> and <code>stopcronjobs()</code>. These functions can be used outside of a web server as well.</p><h2 id="Repeat-Tasks"><a class="docs-heading-anchor" href="#Repeat-Tasks">Repeat Tasks</a><a id="Repeat-Tasks-1"></a><a class="docs-heading-anchor-permalink" href="#Repeat-Tasks" title="Permalink"></a></h2><p>Repeat tasks provide a simple api to run a function on a set interval. </p><p>There are two ways to register repeat tasks: </p><ul><li>Through the <code>interval</code> parameter in a <code>router()</code></li><li>Using the <code>@repeat</code> macro</li></ul><p><strong>It&#39;s important to note that request handlers that use this property can&#39;t define additional function parameters outside of the default <code>HTTP.Request</code> parameter.</strong></p><p>In the example below, the <code>/repeat/hello</code> endpoint is called every 0.5 seconds and <code>&quot;hello&quot;</code> is printed to the console each time.</p><p>The <code>router()</code> function has an <code>interval</code> parameter which is used to call a request handler on a set interval (in seconds). </p><pre><code class="language-julia hljs">using Oxygen

taskrouter = router(&quot;/repeat&quot;, interval=0.5, tags=[&quot;repeat&quot;])

@get taskrouter(&quot;/hello&quot;) function()
    println(&quot;hello&quot;)
end

# you can override properties by setting route specific values 
@get taskrouter(&quot;/bonjour&quot;, interval=1.5) function()
    println(&quot;bonjour&quot;)
end

serve()</code></pre><p>Below is an example of how to register a repeat task outside of the router</p><pre><code class="language-julia hljs">@repeat 1.5 function()
    println(&quot;runs every 1.5 seconds&quot;)
end

# you can also &quot;name&quot; a repeat task 
@repeat 5 &quot;every-five&quot; function()
    println(&quot;runs every 5 seconds&quot;)
end</code></pre><p>When the server is ran, all tasks are started automatically. But the module also provides utilities to have more fine-grained control over the running tasks using the following functions: <code>starttasks()</code>, <code>stoptasks()</code>, and <code>cleartasks()</code></p><h2 id="Hot-reloads-with-Revise"><a class="docs-heading-anchor" href="#Hot-reloads-with-Revise">Hot reloads with Revise</a><a id="Hot-reloads-with-Revise-1"></a><a class="docs-heading-anchor-permalink" href="#Hot-reloads-with-Revise" title="Permalink"></a></h2><p>Oxygen can integrate with Revise to provide hot reloads, speeding up development. Since Revise recommends keeping all code to be revised in a package, you first need to move to this type of a layout.</p><p><a href="https://pkgdocs.julialang.org/v1/toml-files/">First make sure your <code>Project.toml</code> has the required fields such as <code>name</code> to work on a package rather than a project.</a></p><p>Next, write the main code for you routes in a module <code>src/MyModule.jl</code>:</p><pre><code class="nohighlight hljs">module MyModule

using Oxygen; @oxidise

@get &quot;/greet&quot; function(req::HTTP.Request)
    return &quot;hello world!&quot;
end

end</code></pre><p>Then you can make a <code>debug.jl</code> entrypoint script:</p><pre><code class="nohighlight hljs">using Revise
using Oxygen
using MyModule

MyModule.serve(revise=:eager)</code></pre><p>The <code>revise</code> option can also be set to <code>:lazy</code>, in which case revisions will always be left to just before a request is served, rather than being attempted eagerly when source files change on disk.</p><p>Note that you should run another entrypoint script without Revise in production.</p><h2 id="Multiple-Instances"><a class="docs-heading-anchor" href="#Multiple-Instances">Multiple Instances</a><a id="Multiple-Instances-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Instances" title="Permalink"></a></h2><p>In some advanced scenarios, you might need to spin up multiple web severs within the same module on different ports. Oxygen provides both a static and dynamic way to create multiple instances of a web server.</p><p>As a general rule of thumb, if you know how many instances you need ahead of time it&#39;s best to go with the static approach.</p><h3 id="Static:-multiple-instance&#39;s-with-@oxidise"><a class="docs-heading-anchor" href="#Static:-multiple-instance&#39;s-with-@oxidise">Static: multiple instance&#39;s with <code>@oxidise</code></a><a id="Static:-multiple-instance&#39;s-with-@oxidise-1"></a><a class="docs-heading-anchor-permalink" href="#Static:-multiple-instance&#39;s-with-@oxidise" title="Permalink"></a></h3><p>Oxygen provides a new macro which makes it possible to setup and run multiple instances. It generates methods and binds them to a new internal state for the current module. </p><p>In the example below, two simple servers are defined within modules A and B and are started in the parent module. Both modules contain all of the functions exported from Oxygen which can be called directly as shown below.</p><pre><code class="language-julia hljs">module A
    using Oxygen; @oxidise

    get(&quot;/&quot;) do
        text(&quot;server A&quot;)
    end
end

module B
    using Oxygen; @oxidise

    get(&quot;/&quot;) do
        text(&quot;server B&quot;)
    end
end

try 
    # start both instances
    A.serve(port=8001, async=true)
    B.serve(port=8002, async=false)
finally
    # shut down if we `Ctrl+C`
    A.terminate()
    B.terminate()
end</code></pre><h3 id="Dynamic:-multiple-instance&#39;s-with-instance()"><a class="docs-heading-anchor" href="#Dynamic:-multiple-instance&#39;s-with-instance()">Dynamic: multiple instance&#39;s with <code>instance()</code></a><a id="Dynamic:-multiple-instance&#39;s-with-instance()-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic:-multiple-instance&#39;s-with-instance()" title="Permalink"></a></h3><p>The <code>instance</code> function helps you create a completely independent instance of an Oxygen web server at runtime. It works by dynamically creating a julia module at runtime and loading the Oxygen code within it.</p><p>All of the same methods from Oxygen are available under the named instance. In the example below we can use the <code>get</code>, and <code>serve</code> by simply using dot syntax on the <code>app1</code> variable to access the underlying methods.</p><pre><code class="language-julia hljs">using Oxygen

######### Setup the first app #########

app1 = instance()

app1.get(&quot;/&quot;) do
    text(&quot;server A&quot;)
end

######### Setup the second app #########

app2 = instance()

app2.get(&quot;/&quot;) do
    text(&quot;server B&quot;)
end

######### Start both instances #########

try 
    # start both servers together
    app1.serve(port=8001, async=true)
    app2.serve(port=8002)
finally
    # clean it up
    app1.terminate()
    app2.terminate()
end</code></pre><h2 id="Multithreading-and-Parallelism"><a class="docs-heading-anchor" href="#Multithreading-and-Parallelism">Multithreading &amp; Parallelism</a><a id="Multithreading-and-Parallelism-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading-and-Parallelism" title="Permalink"></a></h2><p>For scenarios where you need to handle higher amounts of traffic, you can run Oxygen in a  multithreaded mode. In order to utilize this mode, julia must have more than 1 thread to work with. You can start a julia session with 4 threads using the command below</p><pre><code class="language-shell hljs">julia --threads 4</code></pre><p><span>$serveparallel()$</span> Starts the webserver in streaming mode and handles requests in a cooperative multitasking approach. This function uses <code>Threads.@spawn</code> to schedule a new task on any available thread. Meanwhile, @async is used inside this task when calling each request handler. This allows the task to yield during I/O operations.</p><pre><code class="language-julia hljs">using Oxygen
using StructTypes
using Base.Threads

# Make the Atomic struct serializable
StructTypes.StructType(::Type{Atomic{Int64}}) = StructTypes.Struct()

x = Atomic{Int64}(0);

@get &quot;/show&quot; function()
    return x
end

@get &quot;/increment&quot; function()
    atomic_add!(x, 1)
    return x
end

# start the web server in parallel mode
serveparallel()</code></pre><h2 id="Protocol-Buffers"><a class="docs-heading-anchor" href="#Protocol-Buffers">Protocol Buffers</a><a id="Protocol-Buffers-1"></a><a class="docs-heading-anchor-permalink" href="#Protocol-Buffers" title="Permalink"></a></h2><p>Oxygen includes an extension for the <a href="https://github.com/JuliaIO/ProtoBuf.jl">ProtoBuf.jl</a> package. This extension provides a <code>protobuf()</code> function, simplifying the process of working with Protocol Buffers in the context of web server. For a better understanding of this package, please refer to its official documentation.</p><p>This function has overloads for the following scenarios:</p><ul><li>Decoding a protobuf message from the body of an HTTP request.</li><li>Encoding a protobuf message into the body of an HTTP request.</li><li>Encoding a protobuf message into the body of an HTTP response.</li></ul><pre><code class="language-julia hljs">using HTTP
using ProtoBuf
using Oxygen

# The generated classes need to be created ahead of time (check the protobufs)
include(&quot;people_pb.jl&quot;);
using .people_pb: People, Person

# Decode a Protocol Buffer Message 
@post &quot;/count&quot; function(req::HTTP.Request)
    # decode the request body into a People object
    message = protobuf(req, People)
    # count the number of Person objects
    return length(message.people)
end

# Encode &amp; Return Protocol Buffer message
@get &quot;/get&quot; function()
    message = People([
        Person(&quot;John Doe&quot;, 20),
        Person(&quot;Alice&quot;, 30),
        Person(&quot;Bob&quot;, 35)
    ])
    # seralize the object inside the body of a HTTP.Response
    return protobuf(message)
end</code></pre><p>The following is an example of a schema that was used to create the necessary Julia bindings. These bindings allow for the encoding and decoding of messages in the above example.</p><pre><code class="language-protobuf hljs">syntax = &quot;proto3&quot;;
message Person {
    string name = 1;
    sint32 age = 2;
}
message People {
    repeated Person people = 1;
}</code></pre><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>Oxygen is equipped with several package extensions that enhance its plotting capabilities. These extensions make it easy to return plots directly from request handlers. All operations are performed in-memory using an IOBuffer and return a <code>HTTP.Response</code></p><p>Supported Packages and their helper utils:</p><ul><li>CairoMakie.jl: <code>png</code>, <code>svg</code>, <code>pdf</code>, <code>html</code></li><li>WGLMakie.jl: <code>html</code></li><li>Bonito.jl: <code>html</code></li></ul><h4 id="CairoMakie.jl"><a class="docs-heading-anchor" href="#CairoMakie.jl">CairoMakie.jl</a><a id="CairoMakie.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CairoMakie.jl" title="Permalink"></a></h4><pre><code class="language-julia hljs">using CairoMakie: heatmap
using Oxygen

@get &quot;/cairo&quot; function()
    fig, ax, pl = heatmap(rand(50, 50))
    png(fig)
end

serve()</code></pre><h4 id="WGLMakie.jl"><a class="docs-heading-anchor" href="#WGLMakie.jl">WGLMakie.jl</a><a id="WGLMakie.jl-1"></a><a class="docs-heading-anchor-permalink" href="#WGLMakie.jl" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Bonito
using WGLMakie: heatmap
using Oxygen
using Oxygen: html # Bonito also exports html

@get &quot;/wgl&quot; function()
    fig = heatmap(rand(50, 50))
    html(fig)
end

serve()</code></pre><h4 id="Bonito.jl"><a class="docs-heading-anchor" href="#Bonito.jl">Bonito.jl</a><a id="Bonito.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Bonito.jl" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Bonito
using WGLMakie: heatmap
using Oxygen
using Oxygen: html # Bonito also exports html

@get &quot;/bonito&quot; function()
    app = App() do
        return DOM.div(
            DOM.h1(&quot;Random 50x50 Heatmap&quot;), 
            DOM.div(heatmap(rand(50, 50)))
        )
    end
    return html(app)
end

serve()</code></pre><h2 id="Templating"><a class="docs-heading-anchor" href="#Templating">Templating</a><a id="Templating-1"></a><a class="docs-heading-anchor-permalink" href="#Templating" title="Permalink"></a></h2><p>Rather than building an internal engine for templating or adding additional dependencies, Oxygen  provides two package extensions to support <code>Mustache.jl</code> and <code>OteraEngine.jl</code> templates.</p><p>Oxygen provides a simple wrapper api around both packages that makes it easy to render templates from strings, templates, and files. This wrapper api returns a <code>render</code> function which accepts a dictionary of inputs to fill out the template.</p><p>In all scenarios, the rendered template is returned inside a HTTP.Response object ready to get served by the api. By default, the mime types are auto-detected either by looking at the content of the template or the extension name on the file. If you know the mime type you can pass it directly through the <code>mime_type</code> keyword argument to skip the detection process.</p><h3 id="Mustache-Templating"><a class="docs-heading-anchor" href="#Mustache-Templating">Mustache Templating</a><a id="Mustache-Templating-1"></a><a class="docs-heading-anchor-permalink" href="#Mustache-Templating" title="Permalink"></a></h3><p>Please take a look at the <a href="https://jverzani.github.io/Mustache.jl/dev/">Mustache.jl</a> documentation to learn the full capabilities of the package</p><p>Example 1: Rendering a Mustache Template from a File</p><pre><code class="language-julia hljs">using Mustache
using Oxygen

# Load the Mustache template from a file and create a render function
render = mustache(&quot;./templates/greeting.txt&quot;, from_file=true)

@get &quot;/mustache/file&quot; function()
    data = Dict(&quot;name&quot; =&gt; &quot;Chris&quot;)
    return render(data)  # This will return an HTML.Response with the rendered template
end</code></pre><p>Example 2: Specifying MIME Type for a plain string Mustache Template</p><pre><code class="language-julia hljs">using Mustache
using Oxygen

# Define a Mustache template (both plain strings and mustache templates are supported)
template_str = &quot;Hello, {{name}}!&quot;

# Create a render function, specifying the MIME type as text/plain
render = mustache(template_str, mime_type=&quot;text/plain&quot;) # mime_type keyword arg is optional 

@get &quot;/plain/text&quot; function()
    data = Dict(&quot;name&quot; =&gt; &quot;Chris&quot;)
    return render(data)  # This will return a plain text response with the rendered template
end</code></pre><h3 id="Otera-Templating"><a class="docs-heading-anchor" href="#Otera-Templating">Otera Templating</a><a id="Otera-Templating-1"></a><a class="docs-heading-anchor-permalink" href="#Otera-Templating" title="Permalink"></a></h3><p>Please take a look at the <a href="https://mommawatasu.github.io/OteraEngine.jl/dev/tutorial/#API">OteraEngine.jl</a> documentation to learn the full capabilities of the package</p><p>Example 1: Rendering an Otera Template with Logic and Loops</p><pre><code class="language-julia hljs">using OteraEngine
using Oxygen

# Define an Otera template
template_str = &quot;&quot;&quot;
&lt;html&gt;
    &lt;head&gt;&lt;title&gt;{{ title }}&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;
        {% for name in names %}
        Hello {{ name }}&lt;br&gt;
        {% end %}
    &lt;/body&gt;
&lt;/html&gt;
&quot;&quot;&quot;

# Create a render function for the Otera template
render = otera(template_str)

@get &quot;/otera/loop&quot; function()
    data = Dict(&quot;title&quot; =&gt; &quot;Greetings&quot;, &quot;names&quot; =&gt; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Chris&quot;])
    return render(data)  # This will return an HTML.Response with the rendered template
end</code></pre><p>In this example, an Otera template is defined with a for-loop that iterates over a list of names, greeting each name.</p><p>Example 2: Running Julia Code in Otera Template</p><pre><code class="language-julia hljs">using OteraEngine
using Oxygen

# Define an Otera template with embedded Julia code
template_str = &quot;&quot;&quot;
The square of {{ number }} is {&lt; number^2 &gt;}.
&quot;&quot;&quot;

# Create a render function for the Otera template
render = otera(template_str)

@get &quot;/otera/square&quot; function()
    data = Dict(&quot;number&quot; =&gt; 5)
    return render(data)  # This will return an HTML.Response with the rendered template
end
</code></pre><p>In this example, an Otera template is defined with embedded Julia code that calculates the square of a given number. </p><h2 id="Mounting-Static-Files"><a class="docs-heading-anchor" href="#Mounting-Static-Files">Mounting Static Files</a><a id="Mounting-Static-Files-1"></a><a class="docs-heading-anchor-permalink" href="#Mounting-Static-Files" title="Permalink"></a></h2><p>You can mount static files using this handy function which recursively searches a folder for files and mounts everything. All files are  loaded into memory on startup.</p><pre><code class="language-julia hljs">using Oxygen

# mount all files inside the &quot;content&quot; folder under the &quot;/static&quot; path
staticfiles(&quot;content&quot;, &quot;static&quot;)

# start the web server
serve()</code></pre><h2 id="Mounting-Dynamic-Files"><a class="docs-heading-anchor" href="#Mounting-Dynamic-Files">Mounting Dynamic Files</a><a id="Mounting-Dynamic-Files-1"></a><a class="docs-heading-anchor-permalink" href="#Mounting-Dynamic-Files" title="Permalink"></a></h2><p>Similar to staticfiles, this function mounts each path and re-reads the file for each request. This means that any changes to the files after the server has started will be displayed.</p><pre><code class="language-julia hljs">using Oxygen

# mount all files inside the &quot;content&quot; folder under the &quot;/dynamic&quot; path
dynamicfiles(&quot;content&quot;, &quot;dynamic&quot;)

# start the web server
serve()</code></pre><h2 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h2><p>Disabling the internal logger can provide some massive performance gains, which can be helpful in some scenarios. Anecdotally, i&#39;ve seen a 2-3x speedup in <code>serve()</code> and a 4-5x speedup in <code>serveparallel()</code> performance.</p><pre><code class="language-julia hljs"># This is how you disable internal logging in both modes
serve(access_log=nothing)
serveparallel(access_log=nothing)</code></pre><h2 id="Logging"><a class="docs-heading-anchor" href="#Logging">Logging</a><a id="Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Logging" title="Permalink"></a></h2><p>Oxygen provides a default logging format but allows you to customize the format using the <code>access_log</code> parameter. This functionality is available in both the <code>serve()</code> and <code>serveparallel()</code> functions.</p><p>You can read more about the logging options <a href="https://juliaweb.github.io/HTTP.jl/stable/reference/#HTTP.@logfmt_str">here</a></p><pre><code class="language-julia hljs"># Uses the default logging format
serve()

# Customize the logging format 
serve(access_log=logfmt&quot;[$time_iso8601] \&quot;$request\&quot; $status&quot;)

# Disable internal request logging 
serve(access_log=nothing)</code></pre><h2 id="Middleware"><a class="docs-heading-anchor" href="#Middleware">Middleware</a><a id="Middleware-1"></a><a class="docs-heading-anchor-permalink" href="#Middleware" title="Permalink"></a></h2><p>Middleware functions make it easy to create custom workflows to intercept all incoming requests and outgoing responses. They are executed in the same order they are passed in (from left to right).</p><p>They can be set at the application, router, and route layer with the <code>middleware</code> keyword argument. All middleware is additive and any middleware defined in these layers will be combined and executed.</p><p>Middleware will always be executed in the following order:</p><pre><code class="nohighlight hljs">application -&gt; router -&gt; route</code></pre><p>Now lets see some middleware in action:</p><pre><code class="language-julia hljs">using Oxygen
using HTTP

const CORS_HEADERS = [
    &quot;Access-Control-Allow-Origin&quot; =&gt; &quot;*&quot;,
    &quot;Access-Control-Allow-Headers&quot; =&gt; &quot;*&quot;,
    &quot;Access-Control-Allow-Methods&quot; =&gt; &quot;POST, GET, OPTIONS&quot;
]

# https://juliaweb.github.io/HTTP.jl/stable/examples/#Cors-Server
function CorsMiddleware(handler)
    return function(req::HTTP.Request)
        println(&quot;CORS middleware&quot;)
        # determine if this is a pre-flight request from the browser
        if HTTP.method(req)==&quot;OPTIONS&quot;
            return HTTP.Response(200, CORS_HEADERS)  
        else 
            return handler(req) # passes the request to the AuthMiddleware
        end
    end
end

function AuthMiddleware(handler)
    return function(req::HTTP.Request)
        println(&quot;Auth middleware&quot;)
        # ** NOT an actual security check ** #
        if !HTTP.headercontains(req, &quot;Authorization&quot;, &quot;true&quot;)
            return HTTP.Response(403)
        else 
            return handler(req) # passes the request to your application
        end
    end
end

function middleware1(handle)
    function(req)
        println(&quot;middleware1&quot;)
        handle(req)
    end
end

function middleware2(handle)
    function(req)
        println(&quot;middleware2&quot;)
        handle(req)
    end
end

# set middleware at the router level
math = router(&quot;math&quot;, middleware=[middleware1])

# set middleware at the route level 
@get math(&quot;/divide/{a}/{b}&quot;, middleware=[middleware2]) function(req, a::Float64, b::Float64)
    return a / b
end

# set application level middleware
serve(middleware=[CorsMiddleware, AuthMiddleware])</code></pre><h2 id="Custom-Response-Serializers"><a class="docs-heading-anchor" href="#Custom-Response-Serializers">Custom Response Serializers</a><a id="Custom-Response-Serializers-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Response-Serializers" title="Permalink"></a></h2><p>If you don&#39;t want to use Oxygen&#39;s default response serializer, you can turn it off and add your own! Just create your own special middleware function to serialize the response and add it at the end of your own middleware chain. </p><p>Both <code>serve()</code> and <code>serveparallel()</code> have a <code>serialize</code> keyword argument which can toggle off the default serializer.</p><pre><code class="language-julia hljs">using Oxygen
using HTTP
using JSON3

@get &quot;/divide/{a}/{b}&quot; function(req::HTTP.Request, a::Float64, b::Float64)
    return a / b
end

# This is just a regular middleware function
function myserializer(handle)
    function(req)
        try
          response = handle(req)
          # convert all responses to JSON
          return HTTP.Response(200, [], body=JSON3.write(response)) 
        catch error 
            @error &quot;ERROR: &quot; exception=(error, catch_backtrace())
            return HTTP.Response(500, &quot;The Server encountered a problem&quot;)
        end 
    end
end

# make sure &#39;myserializer&#39; is the last middleware function in this list
serve(middleware=[myserializer], serialize=false)</code></pre><h2 id="Autogenerated-Docs-with-Swagger"><a class="docs-heading-anchor" href="#Autogenerated-Docs-with-Swagger">Autogenerated Docs with Swagger</a><a id="Autogenerated-Docs-with-Swagger-1"></a><a class="docs-heading-anchor-permalink" href="#Autogenerated-Docs-with-Swagger" title="Permalink"></a></h2><p>Swagger documentation is automatically generated for each route you register in your application. Only the route name, parameter types, and 200 &amp; 500 responses are automatically created for you by default. </p><p>You can view your generated documentation at <code>/docs</code>, and the schema can be found under <code>/docs/schema</code>. Both of these values can be changed to whatever you want using the <code>configdocs()</code> function. You can also opt out of autogenerated docs entirely by calling the <code>disabledocs()</code> function  before starting your application. </p><p>To add additional details you can either use the built-in <code>mergeschema()</code> or <code>setschema()</code> functions to directly modify the schema yourself or merge the generated schema from the <code>SwaggerMarkdown.jl</code> package (I&#39;d recommend the latter)</p><p>Below is an example of how to merge the schema generated from the <code>SwaggerMarkdown.jl</code> package.</p><pre><code class="language-julia hljs">using Oxygen
using SwaggerMarkdown

# Here&#39;s an example of how you can merge autogenerated docs from SwaggerMarkdown.jl into your api
@swagger &quot;&quot;&quot;
/divide/{a}/{b}:
  get:
    description: Return the result of a / b
    parameters:
      - name: a
        in: path
        required: true
        description: this is the value of the numerator 
        schema:
          type : number
    responses:
      &#39;200&#39;:
        description: Successfully returned an number.
&quot;&quot;&quot;
@get &quot;/divide/{a}/{b}&quot; function (req, a::Float64, b::Float64)
    return a / b
end

# title and version are required
info = Dict(&quot;title&quot; =&gt; &quot;My Demo Api&quot;, &quot;version&quot; =&gt; &quot;1.0.0&quot;)
openApi = OpenAPI(&quot;3.0&quot;, info)
swagger_document = build(openApi)
  
# merge the SwaggerMarkdown schema with the internal schema
mergeschema(swagger_document)

# start the web server
serve()</code></pre><p>Below is an example of how to manually modify the schema</p><pre><code class="language-julia hljs">using Oxygen
using SwaggerMarkdown

# Only the basic information is parsed from this route when generating docs
@get &quot;/multiply/{a}/{b}&quot; function (req, a::Float64, b::Float64)
    return a * b
end

# Here&#39;s an example of how to update a part of the schema yourself
mergeschema(&quot;/multiply/{a}/{b}&quot;, 
  Dict(
    &quot;get&quot; =&gt; Dict(
      &quot;description&quot; =&gt; &quot;return the result of a * b&quot;
    )
  )
)

# Here&#39;s another example of how to update a part of the schema yourself, but this way allows you to modify other properties defined at the root of the schema (title, summary, etc.)
mergeschema(
  Dict(
    &quot;paths&quot; =&gt; Dict(
      &quot;/multiply/{a}/{b}&quot; =&gt; Dict(
        &quot;get&quot; =&gt; Dict(
          &quot;description&quot; =&gt; &quot;return the result of a * b&quot;
        )
      )
    )
  )
)</code></pre><h1 id="API-Reference-(macros)"><a class="docs-heading-anchor" href="#API-Reference-(macros)">API Reference (macros)</a><a id="API-Reference-(macros)-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference-(macros)" title="Permalink"></a></h1><h4 id="@get,-@post,-@put,-@patch,-@delete"><a class="docs-heading-anchor" href="#@get,-@post,-@put,-@patch,-@delete">@get, @post, @put, @patch, @delete</a><a id="@get,-@post,-@put,-@patch,-@delete-1"></a><a class="docs-heading-anchor-permalink" href="#@get,-@post,-@put,-@patch,-@delete" title="Permalink"></a></h4><pre><code class="language-julia hljs">  @get(path, func)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>path</code></td><td style="text-align: left"><code>string</code> or <code>router()</code></td><td style="text-align: left"><strong>Required</strong>. The route to register</td></tr><tr><td style="text-align: left"><code>func</code></td><td style="text-align: left"><code>function</code></td><td style="text-align: left"><strong>Required</strong>. The request handler for this route</td></tr></table><p>Used to register a function to a specific endpoint to handle that corresponding type of request</p><h4 id="@route"><a class="docs-heading-anchor" href="#@route">@route</a><a id="@route-1"></a><a class="docs-heading-anchor-permalink" href="#@route" title="Permalink"></a></h4><pre><code class="language-julia hljs">  @route(methods, path, func)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>methods</code></td><td style="text-align: left"><code>array</code></td><td style="text-align: left"><strong>Required</strong>. The types of HTTP requests to register to this route</td></tr><tr><td style="text-align: left"><code>path</code></td><td style="text-align: left"><code>string</code> or <code>router()</code></td><td style="text-align: left"><strong>Required</strong>. The route to register</td></tr><tr><td style="text-align: left"><code>func</code></td><td style="text-align: left"><code>function</code></td><td style="text-align: left"><strong>Required</strong>. The request handler for this route</td></tr></table><p>Low-level macro that allows a route to be handle multiple request types</p><h4 id="staticfiles"><a class="docs-heading-anchor" href="#staticfiles">staticfiles</a><a id="staticfiles-1"></a><a class="docs-heading-anchor-permalink" href="#staticfiles" title="Permalink"></a></h4><pre><code class="language-julia hljs">  staticfiles(folder, mount)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>folder</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><strong>Required</strong>. The folder to serve files from</td></tr><tr><td style="text-align: left"><code>mountdir</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left">The root endpoint to mount files under (default is &quot;static&quot;)</td></tr><tr><td style="text-align: left"><code>set_headers</code></td><td style="text-align: left"><code>function</code></td><td style="text-align: left">Customize the http response headers when returning these files</td></tr><tr><td style="text-align: left"><code>loadfile</code></td><td style="text-align: left"><code>function</code></td><td style="text-align: left">Customize behavior when loading files</td></tr></table><p>Serve all static files within a folder. This function recursively searches a directory and mounts all files under the mount directory using their relative paths.</p><h4 id="dynamicfiles"><a class="docs-heading-anchor" href="#dynamicfiles">dynamicfiles</a><a id="dynamicfiles-1"></a><a class="docs-heading-anchor-permalink" href="#dynamicfiles" title="Permalink"></a></h4><pre><code class="language-julia hljs">  dynamicfiles(folder, mount)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>folder</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><strong>Required</strong>. The folder to serve files from</td></tr><tr><td style="text-align: left"><code>mountdir</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left">The root endpoint to mount files under (default is &quot;static&quot;)</td></tr><tr><td style="text-align: left"><code>set_headers</code></td><td style="text-align: left"><code>function</code></td><td style="text-align: left">Customize the http response headers when returning these files</td></tr><tr><td style="text-align: left"><code>loadfile</code></td><td style="text-align: left"><code>function</code></td><td style="text-align: left">Customize behavior when loading files</td></tr></table><p>Serve all static files within a folder. This function recursively searches a directory and mounts all files under the mount directory using their relative paths. The file is loaded on each request, potentially picking up any file changes.</p><h3 id="Request-helper-functions"><a class="docs-heading-anchor" href="#Request-helper-functions">Request helper functions</a><a id="Request-helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Request-helper-functions" title="Permalink"></a></h3><h4 id="html()"><a class="docs-heading-anchor" href="#html()">html()</a><a id="html()-1"></a><a class="docs-heading-anchor-permalink" href="#html()" title="Permalink"></a></h4><pre><code class="language-julia hljs">  html(content, status, headers)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>content</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><strong>Required</strong>. The string to be returned as HTML</td></tr><tr><td style="text-align: left"><code>status</code></td><td style="text-align: left"><code>integer</code></td><td style="text-align: left">The HTTP response code (default is 200)</td></tr><tr><td style="text-align: left"><code>headers</code></td><td style="text-align: left"><code>dict</code></td><td style="text-align: left">The headers for the HTTP response (default has content-type header set to &quot;text/html; charset=utf-8&quot;)</td></tr></table><p>Helper function to designate when content should be returned as HTML</p><h4 id="queryparams()"><a class="docs-heading-anchor" href="#queryparams()">queryparams()</a><a id="queryparams()-1"></a><a class="docs-heading-anchor-permalink" href="#queryparams()" title="Permalink"></a></h4><pre><code class="language-julia hljs">  queryparams(request)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>req</code></td><td style="text-align: left"><code>HTTP.Request</code></td><td style="text-align: left"><strong>Required</strong>. The HTTP request object</td></tr></table><p>Returns the query parameters from a request as a Dict()</p><h3 id="Body-Functions"><a class="docs-heading-anchor" href="#Body-Functions">Body Functions</a><a id="Body-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Body-Functions" title="Permalink"></a></h3><h4 id="text()"><a class="docs-heading-anchor" href="#text()">text()</a><a id="text()-1"></a><a class="docs-heading-anchor-permalink" href="#text()" title="Permalink"></a></h4><pre><code class="language-julia hljs">  text(request)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>req</code></td><td style="text-align: left"><code>HTTP.Request</code></td><td style="text-align: left"><strong>Required</strong>. The HTTP request object</td></tr></table><p>Returns the body of a request as a string</p><h4 id="binary()"><a class="docs-heading-anchor" href="#binary()">binary()</a><a id="binary()-1"></a><a class="docs-heading-anchor-permalink" href="#binary()" title="Permalink"></a></h4><pre><code class="language-julia hljs">  binary(request)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>req</code></td><td style="text-align: left"><code>HTTP.Request</code></td><td style="text-align: left"><strong>Required</strong>. The HTTP request object</td></tr></table><p>Returns the body of a request as a binary file (returns a vector of <code>UInt8</code>s)</p><h4 id="json()"><a class="docs-heading-anchor" href="#json()">json()</a><a id="json()-1"></a><a class="docs-heading-anchor-permalink" href="#json()" title="Permalink"></a></h4><pre><code class="language-julia hljs">  json(request, classtype)</code></pre><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>req</code></td><td style="text-align: left"><code>HTTP.Request</code></td><td style="text-align: left"><strong>Required</strong>. The HTTP request object</td></tr><tr><td style="text-align: left"><code>classtype</code></td><td style="text-align: left"><code>struct</code></td><td style="text-align: left">A struct to deserialize a JSON object into</td></tr></table><p>Deserialize the body of a request into a julia struct </p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">Api »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 24 January 2025 03:48">Friday 24 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
