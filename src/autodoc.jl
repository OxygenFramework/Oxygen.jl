module AutoDoc
using HTTP
using JSON3
using Dates
using DataStructures
using Reexport
using RelocatableFolders

using ..Util: html, recursive_merge
using ..Constants
using ..AppContext: ServerContext, Documenation
using ..Types: TaggedRoute, TaskDefinition, CronDefinition, Nullable, Param, isrequired
using ..Extractors: isextractor, extracttype, isreqparam
using ..Reflection: splitdef

export registerschema, swaggerhtml, redochtml, mergeschema

"""
    mergeschema(route::String, customschema::Dict)

Merge the schema of a specific route
"""
function mergeschema(schema::Dict, route::String, customschema::Dict)
    schema["paths"][route] = recursive_merge(get(schema["paths"], route, Dict()), customschema)
end


"""
    mergeschema(customschema::Dict)

Merge the top-level autogenerated schema with a custom schema
"""
function mergeschema(schema::Dict, customschema::Dict)
    updated_schema = recursive_merge(schema, customschema)
    merge!(schema, updated_schema)
end


"""
Returns the openapi equivalent of each Julia type
"""
function gettype(type::Type)::String
    if type <: Bool
        return "boolean"
    elseif type <: AbstractFloat
        return "number"
    elseif type <: Integer
        return "integer"
    elseif type <: Complex
        return "string"
    elseif type <: Number
        return "number"
    elseif type <: AbstractVector
        return "array"
    elseif type <: Enum
        return "integer"  # Enums are represented as integers in OpenAPI
    elseif type <: String || type == Date || type == DateTime
        return "string"
    elseif isstructtype(type)
        return "object"
    else
        return "string"
    end
end

"""
Returns the specific format type for a given parameter
ex.) DateTime(2022,1,1) => "date-time"
"""
function getformat(type::Type) :: Nullable{String}
    if type <: AbstractFloat
        if type == Float32
            return "float"
        elseif type == Float64
            return "double"
        end
    elseif type <: Integer
        if type == Int32
            return "int32"
        elseif type == Int64
            return "int64"
        end
    elseif type <: Number
        return "double"
    elseif type <: Enum
        # Get the underlying integer type of the enum
        enum_base_type = Base.Enums.basetype(type)
        if enum_base_type == Int32
            return "int32"
        elseif enum_base_type == Int64
            return "int64"
        else
            return "int32"  # Default to int32 for other integer types
        end
    elseif type == Date
        return "date"
    elseif type == DateTime
        return "date-time"
    end
    return nothing
end

function getcomponent(name::AbstractString) :: String
    return "#/components/schemas/$name"
end

function getcomponent(t::DataType) :: String
    return getcomponent(string(nameof(t)))
end

function datetime_hint() :: String
    return "Note: Julia's DateTime object does not natively support timezone information. Consider using the TimeZones.jl package for timezone-aware datetime handling."
end

"""
    extract_non_null_type(T::Type) -> Type

Extract the single non-Nothing/non-Missing type from a Union, or return the type unchanged
if it's not a Union. Returns Union{} if no valid non-null types are found.

# Examples
```julia
extract_non_null_type(Union{String, Nothing}) # Returns String
extract_non_null_type(Union{Int, Missing}) # Returns Int
extract_non_null_type(String) # Returns String (unchanged)
extract_non_null_type(Union{String, Int}) # Warns and returns Union{}
```
"""
function extract_non_null_type(T::Type)::Type
    if !(T isa Union)
        return T
    end
    
    sub_types = Base.uniontypes(T)
    non_null_types = filter(x -> x != Nothing && x != Missing, sub_types)
    # return a single non-null type 
    if length(non_null_types) == 1
        return non_null_types[1]
    # If there are none or multiple non-null types, we don't return them
    else
        return Union{}
    end
end

"""
    is_nullable_union(T::Type) -> Bool

Check if a type is a nullable Union (contains Nothing or Missing along with exactly one other type).

# Examples
```julia
is_nullable_union(Union{String, Nothing}) # Returns true
is_nullable_union(Union{Int, Missing}) # Returns true
is_nullable_union(String) # Returns false
is_nullable_union(Union{String, Int}) # Returns false
```
"""
function is_nullable_union(T::Type)::Bool
    if !(T isa Union)
        return false
    end
    
    sub_types = Base.uniontypes(T)
    has_null = Missing ∈ sub_types || Nothing ∈ sub_types
    non_null_types = filter(x -> x != Nothing && x != Missing, sub_types)
    
    return has_null && length(non_null_types) == 1
end

"""
    resolve_union_type(T::Type) -> Type

Comprehensive Union type resolution that unwraps parametric types and extracts
non-null types from nullable Unions.

# Examples
```julia
resolve_union_type(Union{String, Nothing}) # Returns String
resolve_union_type(Vector{Union{Int, Missing}}) # Returns Vector{Int}
resolve_union_type(String) # Returns String (unchanged)
```
"""
function resolve_union_type(T::Type)::Type
    # First unwrap any parametric wrappers
    T = unwrap_type(T)
    
    # Then extract non-null type if it's a Union
    return extract_non_null_type(T)
end

"""
    process_field_type(field_type::Type) -> Tuple{Type, Bool}

Process a field type and return the resolved type and whether it's nullable.
Handles Union types by extracting non-null types and detecting nullability.

# Returns
- `(resolved_type, is_nullable)`: The resolved non-union type and nullability flag

# Examples
```julia
process_field_type(Union{String, Nothing}) # Returns (String, true)
process_field_type(String) # Returns (String, false)
process_field_type(Union{Int, String}) # Returns (Union{}, false) with warning
```
"""
function process_field_type(field_type::Type)::Tuple{Type, Bool}
    # Unwrap parametric types first
    field_type = unwrap_type(field_type)
    
    # Check if it's nullable
    is_nullable = is_nullable_union(field_type)
    
    # Extract the non-null type
    resolved_type = extract_non_null_type(field_type)
    
    return (resolved_type, is_nullable)
end

"""
    create_array_field_schema(array_type::Type, schemas::Dict, p::Param) -> Dict

Create OpenAPI schema for array/vector fields, handling both custom structs and primitive types.

# Arguments
- `array_type::Type`: The array type to process
- `schemas::Dict`: Schema dictionary to register nested types
- `p::Param`: Parameter information for defaults and other metadata

# Returns
- `Dict`: OpenAPI schema for the array field
"""
function create_array_field_schema(array_type::Type, schemas::Dict, p)::Dict
    field_schema = Dict{String,Any}("type" => "array", "items" => Dict())

    # Extract and unwrap the nested element type
    nested_type = get_element_type(array_type)
    nested_type_name = string(nameof(nested_type))

    # Handle custom structs
    if is_custom_struct(nested_type)
        field_schema["items"] = Dict("\$ref" => getcomponent(nested_type_name))
        # Register type only if not already registered
        if !haskey(schemas, nested_type_name)
            convertobject!(nested_type, schemas)
        end
    else
        # Handle non-custom nested types
        field_schema["items"] = Dict{String,Any}("type" => gettype(nested_type))
        
        # Add enum values if nested type is an enum
        if nested_type <: Enum
            enum_values = collect(Int.(Base.Enums.instances(nested_type)))
            field_schema["items"]["enum"] = enum_values
        end
        
        format = getformat(nested_type)
        
        if !isnothing(format)
            field_schema["items"]["format"] = format
        end

        # Add compatible example format for datetime objects within a vector
        if nested_type <: DateTime
            field_schema["items"]["example"] = example_datetime()
            field_schema["items"]["description"] = datetime_hint()
        end
    end

    # Add default value if it exists
    if p.hasdefault
        field_schema["default"] = JSON3.write(p.default) # for special defaults we need to convert to JSON
    end

    return field_schema
end

"""
    create_primitive_field_schema(field_type::Type, p::Param) -> Dict

Create OpenAPI schema for primitive (non-struct, non-array) fields.

# Arguments
- `field_type::Type`: The primitive type to process
- `p::Param`: Parameter information for defaults and other metadata

# Returns
- `Dict`: OpenAPI schema for the primitive field
"""
function create_primitive_field_schema(field_type::Type, p)::Dict
    field_schema = Dict{String,Any}("type" => gettype(field_type))

    # Add enum values if this is an enum type
    if field_type <: Enum
        enum_values = collect(Int.(Base.Enums.instances(field_type)))
        field_schema["enum"] = enum_values
        # Add format for enums
        format = getformat(field_type)
        if !isnothing(format)
            field_schema["format"] = format
        end
    end

    # Add compatible example format for datetime objects
    if field_type <: DateTime
        field_schema["example"] = example_datetime()
        field_schema["description"] = datetime_hint()
    end

    # Add format if it exists
    format = getformat(field_type)
    if !isnothing(format)
        field_schema["format"] = format
    end

    # Add default value if it exists
    if p.hasdefault 
        field_schema["default"] = string(p.default)
    end

    return field_schema
end

# Unwrap UnionAll (parametric) wrappers to the concrete/body type
function unwrap_type(T::Type)::Type
    while T isa UnionAll
        T = T.body
    end
    return T
end

# Extract the element type from an array-like type (e.g., Array{Person} -> Person)
# Uses Base.eltype with fallback to .parameters for robustness
function get_element_type(T::Type)::Type
    # First, unwrap any parametric wrappers to ensure we're working with a concrete type
    T = unwrap_type(T)
    # Handle the case where T is Union{} (TypeofBottom)
    if T === Union{} || T === Core.TypeofBottom
        return Any
    end
    # Try the canonical eltype method, fallback to parameters lookup
    elem_type = try
        Base.eltype(T)
    catch
        hasfield(T, :parameters) && length(T.parameters) >= 1 ? T.parameters[1] : Any
    end
    # Unwrap the element type itself (in case it's also parametric)
    return unwrap_type(elem_type)
end

function createparam(p::Param{T}, paramtype::String) :: Dict where {T}
    ptype = unwrap_type(p.type)

    schema = Dict{String,Any}("type" => gettype(ptype))

    # Add enum values if this is an enum type
    if ptype <: Enum
        enum_values = collect(Int.(Base.Enums.instances(ptype)))
        schema["enum"] = enum_values
    end

    # Add ref if the type is a custom struct
    if schema["type"] == "object" && is_custom_struct(ptype)
        schema["\$ref"] = getcomponent(string(nameof(ptype)))
    end

    # Add optional format if it's relevant
    format = getformat(ptype)
    if !isnothing(format)
        schema["format"] = format
    end

    # Add default value if it exists
    if p.hasdefault
        schema["default"] = string(p.default)
    end

    # path params are always required
    param_required = paramtype == "path" ? true : isrequired(p)

    param = Dict(
        "in" => paramtype,
        "name" => String(p.name),
        "required" => param_required,
        "schema" => schema
    )

    # Add a string formatting hint & example for DateTime objects
    if ptype <: DateTime 
        param["example"] = example_datetime()
        param["description"] = datetime_hint()
    end

    return param
end

"""
This function helps format the individual parameters for each route in the openapi schema
"""
function formatparam!(params::Vector{Any}, p::Param{T}, paramtype::String) where T
    # Will need to flatten request extrators & append all properties to the schema
    if isextractor(p) && isreqparam(p)
        type = extracttype(p.type)
        info = splitdef(type)
        sig_names = OrderedSet{Symbol}(p.name for p in info.sig)
        for name in sig_names
            push!(params, createparam(info.sig_map[name], paramtype))
        end
    else
        push!(params, createparam(p, paramtype))
    end
end


"""
This function helps format the content object for each route in the openapi schema.

If similar body extractors are used, all schema's are included using an "allOf" relation.
The only exception to this is the text/plain case, which excepts the Body extractor. 
If there are more than one Body extractor, the type defaults to string - since this is 
the only way to represent multiple formats at the same time.
"""
function formatcontent(bodyparams::Vector) :: OrderedDict

    body_refs = Dict{String,Vector{String}}()
    body_types = Dict()

    for p in bodyparams

        inner_type      = p.type |> extracttype
        inner_type_name = inner_type |> nameof |> string
        extractor_name  = p.type |> nameof |> string
        body_types[extractor_name] = gettype(inner_type)

        if !is_custom_struct(inner_type)
            continue
        end

        if !haskey(body_refs, extractor_name)
            body_refs[extractor_name] = []
        end

        body_refs[extractor_name] = vcat(body_refs[extractor_name], getcomponent(inner_type_name))
    end

    jsonschema = collectschemarefs(body_refs, ["Json", "JsonFragment"])
    jsonschema = merge(jsonschema, Dict("type" => "object"))

    # The schema type for text/plain can vary unlike the other types
    textschema = collectschemarefs(body_refs, ["Body"])
    # If there are multiple Body extractors, default to string type
    textschema_type = length(textschema["allOf"]) > 1 ? "string" : get(body_types, "Body", "string")
    textschema = merge(textschema, Dict("type" => textschema_type))

    formschema = collectschemarefs(body_refs, ["Form"])
    formschema = merge(formschema, Dict("type" => "object"))

    content = Dict(
        "application/json" => Dict(
            "schema" => jsonschema
        ),
        "text/plain" => Dict(
            "schema" => textschema
        ),
        "application/x-www-form-urlencoded" => Dict(
            "schema" => formschema
        ),
        "application/xml" => Dict(
            "schema" => Dict(
                "type" => "object"
            )
        ),
        "multipart/form-data" => Dict(
            "schema" => Dict(
                "type" => "object",
                "properties" => Dict(
                    "file" => Dict(
                        "type" => "string",
                        "format" => "binary"
                    )
                ),
                "required" => ["file"]
            )
        )
    )

    ##### Add Schemas to this route, with the preferred content type first #####
    ordered_content = OrderedDict()

    if !isempty(jsonschema["allOf"])
        ordered_content["application/json"] = Dict("schema" => jsonschema)
    end

    if !isempty(textschema["allOf"])
        ordered_content["text/plain"] = Dict("schema" => textschema)
    end

    if !isempty(formschema["allOf"])
        ordered_content["application/x-www-form-urlencoded"] = Dict("schema" => formschema)
    end

    # Add all other content types (won't default to these, but they are available)
    for (key, value) in content
        if !haskey(ordered_content, key)
            ordered_content[key] = value
        end
    end

    return ordered_content
end


"""
Used to generate & register schema related for a specific endpoint 
"""
function registerschema(
    docs::Documenation,
    path::String,
    httpmethod::String,
    parameters::Vector,
    queryparams::Vector,
    headers::Vector,
    bodyparams::Vector,
    returntype::Vector)

    ##### Add all the body parameters to the schema #####

    schemas = Dict()
    for params in [bodyparams, parameters, queryparams, headers]
        for p in params
            inner_type = isextractor(p) ? extracttype(p.type) : p.type
            if is_custom_struct(inner_type)
                convertobject!(inner_type, schemas)
            end
        end
    end

    components = Dict("components" => Dict("schemas" => schemas))
    if !isempty(schemas)
        mergeschema(docs.schema, components)
    end

    ##### Append the parameter schema for the route #####
    params = []

    for (param_list, location) in [(parameters, "path"), (queryparams, "query"), (headers, "header")]
        for p in param_list
            formatparam!(params, p, location)
        end
    end

    ##### Set the schema for the body parameters #####
    content = formatcontent(bodyparams)

    ##### Auto register response schema #####
    response_schema = nothing
    if !isempty(returntype)
        rt = resolve_union_type(returntype[1])

        if rt == Nothing || rt === Union{} || rt === Core.TypeofBottom
            response_schema = Dict("type" => "null")  # Handle empty types explicitly

        elseif is_custom_struct(rt)
            convertobject!(rt, schemas)
            response_schema = Dict("\$ref" => getcomponent(rt))

        elseif rt <: AbstractVector
            elem_type = rt.parameters[1]
            if is_custom_struct(elem_type)
                convertobject!(elem_type, schemas)
                response_schema = Dict(
                    "type" => "array",
                    "items" => Dict("\$ref" => getcomponent(elem_type))
                )
            else
                response_schema = Dict{String,Any}("type" => "array", "items" => Dict("type" => gettype(elem_type)))
                # Add enum values if element type is an enum
                if elem_type <: Enum
                    enum_values = collect(Int.(Base.Enums.instances(elem_type)))
                    response_schema["items"]["enum"] = enum_values
                end
                # Add format if it exists
                format = getformat(elem_type)
                if !isnothing(format)
                    response_schema["items"]["format"] = format
                end
            end
        else
            response_schema = Dict{String,Any}("type" => gettype(rt))
            # Add enum values if return type is an enum
            if rt <: Enum
                enum_values = collect(Int.(Base.Enums.instances(rt)))
                response_schema["enum"] = enum_values
            end
            # Add format if it exists
            format = getformat(rt)
            if !isnothing(format)
                response_schema["format"] = format
            end
        end
    end

    ##### Merge any new schemas from return type #####
    if !isempty(schemas)
        mergeschema(docs.schema, Dict("components" => Dict("schemas" => schemas)))
    end

    # lookup if this route has any registered tags
    if haskey(docs.taggedroutes, path) && httpmethod in docs.taggedroutes[path].httpmethods
        tags = docs.taggedroutes[path].tags
    else
        tags = []
    end

    ##### Build responses field #####
    response_200 = Dict{String, Any}("description" => "200 response")
    if response_schema !== nothing
        response_200["content"] = Dict(
            "application/json" => Dict("schema" => response_schema)
        )
    end
    responses = Dict{String, Any}(
        "200" => response_200,
        "500" => Dict("description" => "500 Server encountered a problem")
    )

    # Build the route schema
    route = Dict(
        "$(lowercase(httpmethod))" => Dict(
            "tags" => tags,
            "parameters" => params,
            "responses" => responses
        )
    )

    # Add a request body to the route if it's a POST, PUT, or PATCH request
    if httpmethod in ["POST", "PUT", "PATCH"] || !isempty(bodyparams)
        route[lowercase(httpmethod)]["requestBody"] = Dict(
            # if any body param is required, mark the entire body as required
            "required" => any(p -> isrequired(p), bodyparams),
            "content" => content
        )
    end

    # remove any special regex patterns from the path before adding this path to the schema
    cleanedpath = replace(path, r"(?=:)(.*?)(?=}/)" => "")
    mergeschema(docs.schema, cleanedpath, route)
end

function collectschemarefs(data::Dict, keys::Vector{String}; schematype="allOf")
    refs = []
    for key in keys
        if haskey(data, key)
            append!(refs, data[key])
        end
    end
    return Dict("$schematype" => [ Dict("\$ref" => ref) for ref in refs ])
end

"""
    is_custom_struct(T::Type) -> Bool

Helper function used to determine if a type is a custom struct and whether or not
we should do a recursive dive and conversion to openapi schema.

Excludes built-in types from Base, Core, Dates, and HTTP.Messages modules.
Handles Union types by checking if any constituent type is a custom struct.

# Examples
```julia
is_custom_struct(MyStruct) # Returns true for user-defined structs
is_custom_struct(String) # Returns false for built-in types
is_custom_struct(Union{MyStruct, Nothing}) # Returns true if MyStruct is custom
```
"""
function is_custom_struct(T::Type) :: Bool
    # Handle the case where T is Union{} (TypeofBottom) or a Union type
    if T === Union{} || T === Core.TypeofBottom
        return false

    elseif T isa Union
        # Check if any of the types in the Union are custom structs
        return any(is_custom_struct, Base.uniontypes(T))
    end

    # Exclude types from Base, Core, Dates, and HTTP.Messages
    if T.name.module ∉ (Base, Core, Dates, HTTP.Messages)
        return isstructtype(T) || isabstracttype(T)
    end

    return false
end

"""
Generate a sample datetime string that's compatible with julia. The one provided
by the openapi spec includes timezone information which is not supported by DateTime objects.

- only make the current year dynamic to avoid giving away information about the server start time.
"""
function example_datetime() :: String
    return Dates.format(now(), "yyyy") * "-01-01T00:00:00.000"
end

# takes a struct and converts it into an openapi 3.0 compliant dictionary
function convertobject!(type::Type, schemas::Dict) :: Dict

    # unwrap parametric/wrapper types (UnionAll) to a concrete/body type
    type = unwrap_type(type)

    # Handle Union types - extract the non-Nothing/non-Missing type
    type = extract_non_null_type(type)
    
    # If we couldn't resolve to a valid type, return early
    if type === Union{}
        @warn "Cannot convert unresolvable Union type"
        return schemas
    end

    typename = type |> nameof |> string

    # Check if this type is already being processed or has been processed
    if haskey(schemas, typename)
        return schemas
    end

    # intilaize this entry
    obj = Dict("type" => "object", "properties" => Dict())
    schemas[typename] = obj  # Placeholder; will be filled below
    required_fields = String[]

    # parse out the fields of the type
    info = splitdef(type)

    # Make sure we have a unique set of names (in case of duplicate field names when parsing types)
    # The same field names can show up as regular parameters and keyword parameters when the type is used with @kwdef
    sig_names = OrderedSet{Symbol}(p.name for p in info.sig)

    # loop over all unique fields
    for name in sig_names

        p = info.sig_map[name]
        field_name = string(p.name)
        current_field = Dict()
        
        # Process the field type to handle Union types and nullability
        resolved_type, is_nullable = process_field_type(p.type)
        
        # Skip fields that couldn't be resolved
        if resolved_type === Union{}
            @warn "OpenAPI $typename.$field_name: Cannot resolve field type."
            continue
        end
        
        # Set nullable flag if needed
        if is_nullable
            current_field["nullable"] = true
        end
        
        current_type = resolved_type
        current_name = string(nameof(current_type))    
        
        # Only add field to required list if it is not nullable (and otherwise required)
        if isrequired(p) && !haskey(current_field, "nullable")
            push!(required_fields, field_name);
        end

        # Case 1: Recursively convert nested structs & register schemas
        if is_custom_struct(current_type)
            current_field["\$ref"] = getcomponent(current_name)
        # Note: We removed the haskey check here; recursion prevention is now handled at the top of this function
            convertobject!(current_type, schemas)

        # Case 2: The custom type is wrapped inside an array or vector
        elseif current_type <: AbstractArray
            current_field = create_array_field_schema(current_type, schemas, p)

        # Case 3: Convert the individual fields of the current type to it's openapi equivalent
        else
            current_field = create_primitive_field_schema(current_type, p)
        end

        # convert the current field
        obj["properties"][field_name] = current_field
    end
    
    # Required fields cannot be an empty collection so define property only if we have data 
    if length(required_fields) > 0 
        obj["required"] = required_fields
    end

    # No need to reassign schemas[typename] = obj, as it's already set and modified in-place

    return schemas
end

"""
Read in a static file from the /data folder
"""
function readstaticfile(filepath::String)::String
    path = joinpath(DATA_PATH, filepath)
    return read(path, String)
end


function redochtml(schemapath::String, docspath::String) :: HTTP.Response
    redocjs = readstaticfile("$REDOC_VERSION/redoc.standalone.js")

    html("""
    <!DOCTYPE html>
    <html lang="en">

        <head>
            <title>Docs</title>
            <meta charset="utf-8"/>
            <meta name="description" content="Docs" />
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <link rel="icon" type="image/x-icon" href="$docspath/metrics/favicon.ico">
        </head>
        
        <body>
            <redoc spec-url="$schemapath"></redoc>
            <script>$redocjs</script>
        </body>

    </html>
    """)
end


"""
Return HTML page to render the autogenerated docs
"""
function swaggerhtml(schemapath::String, docspath::String) :: HTTP.Response

    # load static content files
    swaggerjs = readstaticfile("$SWAGGER_VERSION/swagger-ui-bundle.js")
    swaggerstyles = readstaticfile("$SWAGGER_VERSION/swagger-ui.css")

    html("""
        <!DOCTYPE html>
        <html lang="en">
        
        <head>
            <title>Docs</title>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="description" content="Docs" />
            <style>$swaggerstyles</style>
            <link rel="icon" type="image/x-icon" href="$docspath/metrics/favicon.ico">
        </head>
        
        <body>
            <div id="swagger-ui"></div>
            <script>$swaggerjs</script>
            <script>
                window.onload = () => {
                    window.ui = SwaggerUIBundle({
                        url: "$schemapath",
                        dom_id: '#swagger-ui',
                    });
                };
            </script>
        </body>
        
        </html>
    """)
end

end
