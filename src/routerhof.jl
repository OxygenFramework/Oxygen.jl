module RouterHOF

using HTTP

using ..Util: join_url_path
using ..AppContext: ServerContext, Documenation
using ..Types: TaggedRoute, TaskDefinition, CronDefinition, Nullable, LifecycleMiddleware

export router, compose, genkey, process_middleware

"""
normalizes a list of middleware functions and LifecycleMiddleware structs
"""
function process_middleware(ctx::ServerContext, middleware::Vector) :: Vector{Function}
    processed = []
    for mw in middleware
        if mw isa LifecycleMiddleware
            push!(ctx.service.lifecycle_middleware, mw)
            push!(processed, mw.middleware)
        else
            push!(processed, mw)
        end
    end
    return processed
end

# Do nothing if we have no middleware to append
function process_middleware(::ServerContext, ::Nothing) end


"""
This function is used to generate dictionary keys which lookup middleware for routes
"""
function genkey(httpmethod::String, path::String)::String
    return "$httpmethod|$path"
end

"""
This function is used to build up the middleware chain for all our endpoints
"""
function buildmiddleware(key::String, handler::Function, globalmiddleware::Vector, custommiddleware::Dict) :: Function

    # lookup the middleware for this path
    routermiddleware, routemiddleware = get(custommiddleware, key, (nothing, nothing))

    # sanitize outputs (either value can be nothing)
    routermiddleware = isnothing(routermiddleware) ? [] : routermiddleware
    routemiddleware = isnothing(routemiddleware) ? [] : routemiddleware

    # initialize our middleware layers
    layers::Vector{Function} = [handler]

    # append the middleware in reverse order (so when we reduce over it, it's in the correct order)
    append!(layers, routemiddleware)
    append!(layers, routermiddleware)
    append!(layers, globalmiddleware)

    # combine all the middleware functions together
    return reduce(|>, layers)
end

"""
This function dynamically determines which middleware functions to apply to a request at runtime. 
If router or route specific middleware is defined, then it's used instead of the globally defined
middleware. 
"""
function compose(router::HTTP.Router, cache_lock::ReentrantLock, globalmiddleware::Vector, custommiddleware::Dict, middleware_cache::Dict)
    return function (handler)
        return function (req::HTTP.Request)

            innerhandler, path, _ = HTTP.Handlers.gethandler(router, req)

            # Check if the current request matches one of our predefined routes 
            if innerhandler !== nothing

                # Check if we already have a cached middleware function for this specific route
                key = genkey(req.method, path)
                func = get(middleware_cache, key, nothing)
                if !isnothing(func)
                    return func(req)
                end

                # Combine all the middleware functions together 
                strategy = buildmiddleware(key, handler, globalmiddleware, custommiddleware)
                
                ## Below Double-checked locking is used to reduce the overhead of acquiring a lock
                if !haskey(middleware_cache, key)
                    lock(cache_lock) do 
                        if !haskey(middleware_cache, key)
                            middleware_cache[key] = strategy
                        end
                    end
                end
                
                return strategy(req)
            end
    
            return handler(req)
        end
    end
end


"""
This functions assists registering routes with a specific prefix.
You can optionally assign tags either at the prefix and/or route level which
are used to group and organize the autogenerated documentation
"""
function router(ctx::ServerContext, prefix::String="";
    tags::Vector{String}=Vector{String}(),
    middleware::Nullable{Vector}=nothing,
    interval::Nullable{Real}=nothing,
    cron::Nullable{String}=nothing)

    return createrouter(ctx, prefix, tags, middleware, interval, cron)
end

function createrouter(ctx::ServerContext, prefix::String,
    routertags::Vector{String},
    routermiddleware::Nullable{Vector},
    routerinterval::Nullable{Real},
    routercron::Nullable{String}=nothing)

    # ensure we collect & process any lifecycle-middleware functions
    routermiddleware = process_middleware(ctx, routermiddleware)

    # appends a "/" character to the given string if doesn't have one. 
    function fixpath(path::String)
        path = String(strip(path))
        if !isnothing(path) && !isempty(path) && path !== "/"
            return startswith(path, "/") ? path : "/$path"
        end
        return ""
    end

    # This function takes input from the user next to the request handler
    return function (path=nothing;
        tags::Vector{String}=Vector{String}(),
        middleware::Nullable{Vector}=nothing,
        interval::Nullable{Real}=routerinterval,
        cron::Nullable{String}=routercron)

        # ensure we collect & process any lifecycle-middleware functions
        middleware = process_middleware(ctx, middleware)

        # this is called inside the @register macro (only it knows the exact httpmethod associated with each path)
        return function (httpmethod::String)

            """
            This scenario can happen when the user passes a router object directly like so: 

            @get router("/math/power/{a}/{b}") function (req::HTTP.Request, a::Float64, b::Float64)
                return a ^ b
            end

            Under normal circumstances, the function returned by the router call is used when registering routes. 
            However, in this specific case, the call to router returns a higher-order function (HOF) that's nested one 
            layer deeper than expected.

            Due to the way we call these functions to derive the path for the currently registered route, 
            the path argument can sometimes be mistakenly set to the HTTP method (e.g., "GET", "POST"). 
            This can lead to the path getting concatenated with the HTTP method string.

            To account for this specific use case, we've added a check in the inner function to verify whether 
            path matches the current passed in httpmethod. If it does, we assume that path has been incorrectly 
            set to the HTTP method, and we update path to use the router prefix instead.
            """
            if path === httpmethod
                final_path = prefix
            else
                final_path = !isnothing(path) ? join_url_path(prefix, path) : join_url_path(prefix, "")
            end

            if !(isnothing(routermiddleware) && isnothing(middleware))
                ctx.service.custommiddleware[genkey(httpmethod, final_path)] = (routermiddleware, middleware)
            end

            if !isnothing(interval) && interval >= 0.0
                task = TaskDefinition(final_path, httpmethod, interval)
                push!(ctx.tasks.task_definitions, task)
            end

            if !isnothing(cron) && !isempty(cron)
                job = CronDefinition(final_path, httpmethod, cron)
                push!(ctx.cron.job_definitions, job)
            end

            combinedtags = [tags..., routertags...]

            if !haskey(ctx.docs.taggedroutes, final_path)
                ctx.docs.taggedroutes[final_path] = TaggedRoute([httpmethod], combinedtags)
            else
                combinedmethods = vcat(httpmethod, ctx.docs.taggedroutes[final_path].httpmethods)
                ctx.docs.taggedroutes[final_path] = TaggedRoute(combinedmethods, combinedtags)
            end

            return final_path
        end
    end
end


end