module RouterHOF

using HTTP

using ..Util: join_url_path
using ..AppContext: ServerContext, Documenation
using ..Types: TaggedRoute, TaskDefinition, CronDefinition, Nullable, LifecycleMiddleware

export router, compose, genkey, process_middleware, HOFRouter, OuterRouter, InnerRouter

"""
normalizes a list of middleware functions and LifecycleMiddleware structs
"""
function process_middleware(ctx::ServerContext, middleware::Vector) :: Vector{Function}
    processed = []
    for mw in middleware
        if mw isa LifecycleMiddleware
            push!(ctx.service.lifecycle_middleware, mw)
            push!(processed, mw.middleware)
        else
            push!(processed, mw)
        end
    end
    return processed
end

# Do nothing if we have no middleware to append
function process_middleware(::ServerContext, ::Nothing) end


"""
This function is used to generate dictionary keys which lookup middleware for routes
"""
function genkey(httpmethod::String, path::String)::String
    return "$httpmethod|$path"
end

"""
This function is used to build up the middleware chain for all our endpoints
"""
function buildmiddleware(key::String, handler::Function, globalmiddleware::Vector, custommiddleware::Dict) :: Function

    # lookup the middleware for this path
    routermiddleware, routemiddleware = get(custommiddleware, key, (nothing, nothing))

    # sanitize outputs (either value can be nothing)
    routermiddleware = isnothing(routermiddleware) ? [] : routermiddleware
    routemiddleware = isnothing(routemiddleware) ? [] : routemiddleware

    # initialize our middleware layers
    layers::Vector{Function} = [handler]

    # append the middleware in reverse order (so when we reduce over it, it's in the correct order)
    append!(layers, routemiddleware)
    append!(layers, routermiddleware)
    append!(layers, globalmiddleware)

    # combine all the middleware functions together
    return reduce(|>, layers)
end

"""
This function dynamically determines which middleware functions to apply to a request at runtime. 
If router or route specific middleware is defined, then it's used instead of the globally defined
middleware. 
"""
function compose(router::HTTP.Router, cache_lock::ReentrantLock, globalmiddleware::Vector, custommiddleware::Dict, middleware_cache::Dict)
    return function (handler)
        return function (req::HTTP.Request)

            innerhandler, path, _ = HTTP.Handlers.gethandler(router, req)

            # Check if the current request matches one of our predefined routes 
            if innerhandler !== nothing

                # Check if we already have a cached middleware function for this specific route
                key = genkey(req.method, path)
                func = get(middleware_cache, key, nothing)
                if !isnothing(func)
                    return func(req)
                end

                # Combine all the middleware functions together 
                strategy = buildmiddleware(key, handler, globalmiddleware, custommiddleware)
                
                ## Below Double-checked locking is used to reduce the overhead of acquiring a lock
                if !haskey(middleware_cache, key)
                    lock(cache_lock) do 
                        if !haskey(middleware_cache, key)
                            middleware_cache[key] = strategy
                        end
                    end
                end
                
                return strategy(req)
            end
    
            return handler(req)
        end
    end
end


"""
This functions assists registering routes with a specific prefix.
You can optionally assign tags either at the prefix and/or route level which
are used to group and organize the autogenerated documentation
"""
function router(ctx::ServerContext, prefix::String="";
    tags::Vector{String}=Vector{String}(),
    middleware::Nullable{Vector}=nothing,
    interval::Nullable{Real}=nothing,
    cron::Nullable{String}=nothing)

    # ensure we collect & process any lifecycle-middleware functions
    router_middleware = process_middleware(ctx, middleware)

    return OuterRouter(ctx, prefix, tags, router_middleware, interval, cron)
end


"""
Abstract supertype for higher-order function (HOF) routers in Oxygen.

This type serves as the base for `OuterRouter` and `InnerRouter`, enabling composable routing patterns
with features like prefixes, middleware, tags, intervals, and cron jobs. HOF routers allow building
nested route configurations by chaining callable instances.
"""
abstract type HOFRouter end

struct OuterRouter <: HOFRouter
    ctx::ServerContext
    prefix::String
    routertags::Vector{String}
    routermiddleware::Nullable{Vector}
    routerinterval::Nullable{Real}
    routercron::Nullable{String}
end

function (outer::OuterRouter)(path=nothing;
    tags::Vector{String}=Vector{String}(),
    middleware::Nullable{Vector}=nothing,
    interval::Nullable{Real}=outer.routerinterval,
    cron::Nullable{String}=outer.routercron)

    # ensure we collect & process any lifecycle-middleware functions
    processed_middleware = process_middleware(outer.ctx, middleware)

    return InnerRouter(outer.ctx, outer.prefix, outer.routertags, outer.routermiddleware, path, tags, processed_middleware, interval, cron)
end

struct InnerRouter <: HOFRouter
    ctx::ServerContext
    prefix::String
    routertags::Vector{String}
    routermiddleware::Nullable{Vector}
    path::Union{Nothing, String}
    tags::Vector{String}
    middleware::Nullable{Vector}
    interval::Nullable{Real}
    cron::Nullable{String}
end

function (inner::InnerRouter)(httpmethod::String)
    """
    This scenario can happen when the user passes a router object directly like so: 

    @get router("/math/power/{a}/{b}") function (req::HTTP.Request, a::Float64, b::Float64)
        return a ^ b
    end

    Under normal circumstances, the function returned by the router call is used when registering routes. 
    However, in this specific case, the call to router returns a higher-order function (HOF) that's nested one 
    layer deeper than expected.

    Due to the way we call these functions to derive the path for the currently registered route, 
    the path argument can sometimes be mistakenly set to the HTTP method (e.g., "GET", "POST"). 
    This can lead to the path getting concatenated with the HTTP method string.

    To account for this specific use case, we've added a check in the inner function to verify whether 
    path matches the current passed in httpmethod. If it does, we assume that path has been incorrectly 
    set to the HTTP method, and we update path to use the router prefix instead.
    """
    if inner.path === httpmethod
        final_path = inner.prefix
    else
        final_path = !isnothing(inner.path) ? join_url_path(inner.prefix, inner.path) : join_url_path(inner.prefix, "")
    end

    if !(isnothing(inner.routermiddleware) && isnothing(inner.middleware))
        inner.ctx.service.custommiddleware[genkey(httpmethod, final_path)] = (inner.routermiddleware, inner.middleware)
    end

    if !isnothing(inner.interval) && inner.interval >= 0.0
        task = TaskDefinition(final_path, httpmethod, inner.interval)
        push!(inner.ctx.tasks.task_definitions, task)
    end

    if !isnothing(inner.cron) && !isempty(inner.cron)
        job = CronDefinition(final_path, httpmethod, inner.cron)
        push!(inner.ctx.cron.job_definitions, job)
    end

    combinedtags = [inner.tags..., inner.routertags...]

    if !haskey(inner.ctx.docs.taggedroutes, final_path)
        inner.ctx.docs.taggedroutes[final_path] = TaggedRoute([httpmethod], combinedtags)
    else
        combinedmethods = vcat(httpmethod, inner.ctx.docs.taggedroutes[final_path].httpmethods)
        inner.ctx.docs.taggedroutes[final_path] = TaggedRoute(combinedmethods, combinedtags)
    end

    return final_path
end



end