var documenterSearchIndex = {"docs":
[{"location":"tutorial/bigger_applications/#Bigger-Applications-Multiple-Files","page":"Bigger Applications - Multiple Files","title":"Bigger Applications - Multiple Files","text":"If you are building an application or a web API, it's rarely the case that you can put everything on a single file.\n\nAs your application grows you'll need to spread your application's logic across multiple files. Oxygen provides some tools to help you do this while staying organized.\n\nLet's say you have an application that looks something like this:\n\napp\n├── src\n│   ├── main.jl\n│   └── MathOperations.jl\n│\n├── Project.toml\n└── Manifest.toml","category":"section"},{"location":"tutorial/bigger_applications/#How-to-use-the-router()-function","page":"Bigger Applications - Multiple Files","title":"How to use the router() function","text":"Let's say you have a file dedicated to handling mathematical operations in the submodule at /src/MathOperations.jl.\n\nYou might want the first part of each path to have the same value and just switch out the subpath to keep things organized in your api. You can use the router function to do just that. \n\nThe router() function is an HOF (higher order function) that allows you to reuse the same properties across multiple endpoints.\n\nBecause the generated router is just a function, they can be exported and shared across multiple files & modules.\n\nusing Oxygen\n\nmath = router(\"/math\", tags=[\"math\"])\n\n@get math(\"/multiply/{a}/{b}\", tags=[\"multiplication\"]) function(req, a::Float64, b::Float64)\n    return a * b\nend\n\n@get math(\"/divide/{a}/{b}\") function(req, a::Float64, b::Float64)\n    return a / b\nend\n\nserve()","category":"section"},{"location":"tutorial/bigger_applications/#Tagging-your-routes","page":"Bigger Applications - Multiple Files","title":"Tagging your routes","text":"By using the hello router in both endpoints, it passes along all the properties as default values. For example If we look at the routes registered in the application they will look like:\n\n/math/multiply/{a}/{b}\n/math/divide/{a}/{b}\n\nBoth endpoints in this case will be tagged to the math tag and the /multiply endpoint will have an additional tag appended just to this endpoint called multiplication. These tags are used by Oxygen when auto-generating the documentation to organize it by separating the endpoints into sections based off their tags. ","category":"section"},{"location":"tutorial/bigger_applications/#Middleware-and-router()","page":"Bigger Applications - Multiple Files","title":"Middleware & router()","text":"The router() function has a middleware parameter which takes a vector of middleware functions which are used to intercept all incoming requests & outgoing responses.\n\nAll middleware is additive and any middleware defined in these layers will be combined and executed.\n\nYou can assign middleware at three levels:\n\napplication \nrouter \nroute \n\nMiddleware will always get executed in the following order:\n\napplication -> router -> route\n\nthe application layer can only be set from the serve() and serveparallel() functions. While the other two layers can be set using the router() function.\n\n# Set middleware at the application level\nserve(middleware=[])\n\n# Set middleware at the Router level\nmyrouter = router(\"/router\", middleware=[])\n\n# Set middleware at the Route level\n@get myrouter(\"/example\", middleware=[]) function()\n    return \"example\"\nend","category":"section"},{"location":"tutorial/bigger_applications/#Router-Level-Middleware","page":"Bigger Applications - Multiple Files","title":"Router Level Middleware","text":"At the router level, any middleware defined here will be reused across  all other routes that use this router(). In the example below, both /greet/hello  and /greet/bonjour routes will send requests through the same middleware functions before either endpoint is called\n\nfunction middleware1(handle)\n    function(req)\n        println(\"this is the 1st middleware function\")\n        handle(req)\n    end\nend\n\n# middleware1 is defined at the router level\ngreet = router(\"/greet\", middleware=[middleware1])\n\n@get greet(\"/hello\") function()\n    println(\"hello\")\nend\n\n@get greet(\"/bonjour\") function()\n    println(\"bonjour\")\nend","category":"section"},{"location":"tutorial/bigger_applications/#Route-Specific-Middleware","page":"Bigger Applications - Multiple Files","title":"Route Specific Middleware","text":"At the route level, you can customize what middleware functions should be applied on a route by route basis. In the example below, the /greet/hello route gets both middleware1 & middleware2 functions applied to it, while the /greet/bonjour  route only has middleware1 function which it inherited from the greet router.\n\nfunction middleware1(handle)\n    function(req)\n        println(\"this is the 1st middleware function\")\n        handle(req)\n    end\nend\n\nfunction middleware2(handle)\n    function(req)\n        println(\"this is the 2nd middleware function\")\n        handle(req)\n    end\nend\n\n# middleware1 is added at the router level\ngreet = router(\"/greet\", middleware=[middleware1])\n\n# middleware2 is added at the route level\n@get greet(\"/hello\", middleware=[middleware2]) function()\n    println(\"hello\")\nend\n\n@get greet(\"/bonjour\") function()\n    println(\"bonjour\")\nend\n\nserve()","category":"section"},{"location":"tutorial/bigger_applications/#Skipping-Middleware-layers","page":"Bigger Applications - Multiple Files","title":"Skipping Middleware layers","text":"Well, what if we don't want previous layers of middleware to run?  By setting middleware=[], it clears all middleware functions at that layer and skips all layers that come before it. These changes are localized and only affect the components where these values are set.\n\nFor example, setting middleware=[] at the:\n\napplication layer -> clears the application layer\nrouter layer -> no application middleware is applied to this router\nroute layer -> no router middleware is applied to this route\n\nYou can set the router's middleware parameter to an empty vector to bypass any application level middleware. In the example below, all requests to endpoints registered to the greet router() will skip any application level  middleware and get executed directly.\n\nfunction middleware1(handle)\n    function(req)\n        println(\"this is the 1st middleware function\")\n        handle(req)\n    end\nend\n\ngreet = router(\"/greet\", middleware=[])\n\n@get greet(\"/hello\") function()\n    println(\"hello\")\nend\n\n@get greet(\"/bonjour\") function()\n    println(\"bonjour\")\nend\n\nserve(middleware=[middleware1])","category":"section"},{"location":"tutorial/bigger_applications/#Repeat-Actions","page":"Bigger Applications - Multiple Files","title":"Repeat Actions","text":"The router() function has an interval parameter which is used to call a request handler on a set interval (in seconds). \n\nIt's important to note that request handlers that use this property can't define additional function parameters outside of the default HTTP.Request parameter.\n\nIn the example below, the /repeat/hello endpoint is called every 0.5 seconds and \"hello\" is printed to the console each time.\n\nusing Oxygen\n\nrepeat = router(\"/repeat\", interval=0.5, tags=[\"repeat\"])\n\n@get repeat(\"/hello\") function()\n    println(\"hello\")\nend\n\n# you can override properties by setting route specific values \n@get repeat(\"/bonjour\", interval=1.5) function()\n    println(\"bonjour\")\nend\n\nserve()\n\nIf you want to call an endpoint with parameters on a set interval, you're better off creating an endpoint to perform the action you want and a second endpoint to call the first on a set interval. \n\nusing HTTP\nusing Oxygen\n\nrepeat = router(\"/repeat\", interval=1.5, tags=[\"repeat\"])\n\n@get \"/multiply/{a}/{b}\" function(req, a::Float64, b::Float64)\n    return a * b\nend\n\n@get repeat(\"/multiply\") function()\n    response = internalrequest(HTTP.Request(\"GET\", \"/multiply/3/5\"))\n    println(response)\n    return response\nend\n\nserve()\n\nThe example above will print the response from the /multiply endpoint in the console below every 1.5 seconds and should look like this:\n\n\"\"\"\nHTTP/1.1 200 OK\nContent-Type: application/json; charset=utf-8\n\n15.0\"\"\"","category":"section"},{"location":"tutorial/request_types/#Request-Types","page":"Request Types","title":"Request Types","text":"When designing an API you need to first think about what type of requests and what routes or paths your api would need to function. \n\nFor example, if we were to design a weather app we'd probably want a way to lookup weather alerts for a particular state\n\nhttp://localhost:8080/weather/alerts/{state}\n\nThis url can be broken down into several parts \n\nhost → http://localhost\nport → 8080\nroute or path → /weather/alerts/{state}\npath parameter → {state}\n\nBefore we start writing code for we need to answer some questions: \n\nWhat kind of data manipulation is this route going to perform?\nAre we adding/removing/updating data? (This determines our http method)\nWill this endpoint need any inputs?\nIf so, will we need to pass them through the path or inside the body of the http request?\n\nThis is when knowing the different type of http methods comes in handy.\n\nCommon HTTP methods:\n\nPOST → when you want to create some data\nGET → when you want to get data\nPUT → update some data if it already exists or create it\nPATCH → when you want to update some data\nDELETE → when you want to delete some data\n\n(there are more methods that aren't in this list)\n\nIn the HTTP protocol, you can communicate to each path using one (or more) of these \"methods\".\n\nIn reality you can use any of these http methods to do any of those operations. But it's heavily recommended to use the appropriate http method so that people & machines can easily understand your web api. \n\nNow back to our web example. Lets answer those questions:\n\nThis endpoint will return alerts from the US National Weather service api\nThe only input we will need is the state abbreviation\n\nSince we will only be fetching data and not creating/updating/deleting anything, that means we will want to setup a GET route for our api to handle this type of action.\n\nusing Oxygen\nusing HTTP\n\n@get \"/weather/alerts/{state}\" function(req::HTTP.Request, state::String)\n    return HTTP.get(\"https://api.weather.gov/alerts/active?area=$state\")\nend\n\nserve() \n\nWith our code in place, we can run this code and visit the endpoint in our browser to view the alerts. Try it out yourself by clicking on the link below. \n\nhttp://127.0.0.1:8080/weather/alerts/NY","category":"section"},{"location":"api/#Api","page":"Api","title":"Api","text":"Documentation for Oxygen.jl","category":"section"},{"location":"api/#Starting-the-webserver","page":"Api","title":"Starting the webserver","text":"","category":"section"},{"location":"api/#Routing","page":"Api","title":"Routing","text":"","category":"section"},{"location":"api/#Mounting-Files","page":"Api","title":"Mounting Files","text":"","category":"section"},{"location":"api/#Autogenerated-Docs","page":"Api","title":"Autogenerated Docs","text":"","category":"section"},{"location":"api/#Helper-functions","page":"Api","title":"Helper functions","text":"","category":"section"},{"location":"api/#Repeat-Tasks-and-Cron-Scheduling","page":"Api","title":"Repeat Tasks & Cron Scheduling","text":"","category":"section"},{"location":"api/#Extra's","page":"Api","title":"Extra's","text":"","category":"section"},{"location":"api/#Oxygen.serve","page":"Api","title":"Oxygen.serve","text":"serve(; middleware::Vector=[], handler=stream_handler, host=\"127.0.0.1\", port=8080, async=false, parallel=false, serialize=true, catch_errors=true, docs=true, metrics=true, show_errors=true, show_banner=true, docs_path=\"/docs\", schema_path=\"/schema\", external_url=nothing, revise, kwargs...)\n\nStart the webserver with your own custom request handler\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.serveparallel","page":"Api","title":"Oxygen.serveparallel","text":"serveparallel(; middleware::Vector=[], handler=stream_handler, host=\"127.0.0.1\", port=8080, serialize=true, async=false, catch_errors=true, docs=true, metrics=true, kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.@get-Tuple{Any, Any}","page":"Api","title":"Oxygen.@get","text":"@get(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle GET requests  \n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.@post-Tuple{Any, Any}","page":"Api","title":"Oxygen.@post","text":"@post(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle POST requests\n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.@put-Tuple{Any, Any}","page":"Api","title":"Oxygen.@put","text":"@put(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle PUT requests\n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.@patch-Tuple{Any, Any}","page":"Api","title":"Oxygen.@patch","text":"@patch(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle PATCH requests\n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.@delete-Tuple{Any, Any}","page":"Api","title":"Oxygen.@delete","text":"@delete(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle DELETE requests\n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.@route-Tuple{Any, Any, Any}","page":"Api","title":"Oxygen.@route","text":"@route(methods::Array{String}, path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle mulitiple request types\n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.@staticfiles","page":"Api","title":"Oxygen.@staticfiles","text":"@staticfiles(folder::String, mountdir::String, headers::Vector{Pair{String,String}}=[])\n\nMount all files inside the /static folder (or user defined mount point)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.@dynamicfiles","page":"Api","title":"Oxygen.@dynamicfiles","text":"@dynamicfiles(folder::String, mountdir::String, headers::Vector{Pair{String,String}}=[])\n\nMount all files inside the /static folder (or user defined mount point),  but files are re-read on each request\n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.staticfiles","page":"Api","title":"Oxygen.staticfiles","text":"staticfiles(folder::String, mountdir::String; headers::Vector{Pair{String,String}}=[], loadfile::Union{Function,Nothing}=nothing)\n\nMount all files inside the /static folder (or user defined mount point).  The headers array will get applied to all mounted files\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.dynamicfiles","page":"Api","title":"Oxygen.dynamicfiles","text":"dynamicfiles(folder::String, mountdir::String; headers::Vector{Pair{String,String}}=[], loadfile::Union{Function,Nothing}=nothing)\n\nMount all files inside the /static folder (or user defined mount point),  but files are re-read on each request. The headers array will get applied to all mounted files\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.configdocs","page":"Api","title":"Oxygen.configdocs","text":"configdocs(docspath::String = \"/docs\", schemapath::String = \"/schema\")\n\nConfigure the default docs and schema endpoints\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.mergeschema","page":"Api","title":"Oxygen.mergeschema","text":"mergeschema(route::String, customschema::Dict)\n\nMerge the schema of a specific route\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.setschema","page":"Api","title":"Oxygen.setschema","text":"setschema(customschema::Dict)\n\nOverwrites the entire internal schema\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.getschema","page":"Api","title":"Oxygen.getschema","text":"getschema()\n\nReturn the current internal schema for this app\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.formdata","page":"Api","title":"Oxygen.Core.Util.formdata","text":"formdata(request::HTTP.Request)\n\nRead the html form data from the body of a HTTP.Request\n\n\n\n\n\nformdata(request::HTTP.Response)\n\nRead the html form data from the body of a HTTP.Response\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.html","page":"Api","title":"Oxygen.Core.Util.html","text":"html(content::String; status::Int, headers::Vector{Pair}) :: HTTP.Response\n\nA convenience function to return a String that should be interpreted as HTML\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.text","page":"Api","title":"Oxygen.Core.Util.text","text":"text(request::HTTP.Request)\n\nRead the body of a HTTP.Request as a String\n\n\n\n\n\ntext(response::HTTP.Response)\n\nRead the body of a HTTP.Response as a String\n\n\n\n\n\ntext(content::String; status::Int, headers::Vector{Pair}) :: HTTP.Response\n\nA convenience function to return a String that should be interpreted as plain text\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.file","page":"Api","title":"Oxygen.Core.Util.file","text":"file(filepath::String; loadfile=nothing, status = 200, headers = []) :: HTTP.Response\n\nReads a file and returns a HTTP.Response. The file is read as binary. If the file does not exist,  an ArgumentError is thrown. The MIME type and the size of the file are added to the headers.\n\nArguments\n\nfilepath: The path to the file to be read.\nloadfile: An optional function to load the file. If not provided, the file is read using the open function.\nstatus: The HTTP status code to be used in the response. Defaults to 200.\nheaders: Any additional headers to be included in the response. Defaults to an empty array.\n\nReturns\n\nA HTTP response.\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.xml","page":"Api","title":"Oxygen.Core.Util.xml","text":"xml(content::String; status::Int, headers::Vector{Pair}) :: HTTP.Response\n\nA convenience function to return a String that should be interpreted as XML\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.js","page":"Api","title":"Oxygen.Core.Util.js","text":"js(content::String; status::Int, headers::Vector{Pair}) :: HTTP.Response\n\nA convenience function to return a String that should be interpreted as JavaScript\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.json","page":"Api","title":"Oxygen.Core.Util.json","text":"json(request::HTTP.Request; keyword_arguments...)\n\nRead the body of a HTTP.Request as JSON with additional arguments for the read/serializer.\n\n\n\n\n\njson(request::HTTP.Request, class_type; keyword_arguments...)\n\nRead the body of a HTTP.Request as JSON with additional arguments for the read/serializer into a custom struct.\n\n\n\n\n\njson(response::HTTP.Response; keyword_arguments)\n\nRead the body of a HTTP.Response as JSON with additional keyword arguments\n\n\n\n\n\njson(response::HTTP.Response, class_type; keyword_arguments)\n\nRead the body of a HTTP.Response as JSON with additional keyword arguments and serialize it into a custom struct\n\n\n\n\n\njson(content::Any; status::Int, headers::Vector{Pair}) :: HTTP.Response\n\nA convenience function to return a String that should be interpreted as JSON\n\n\n\n\n\njson(content::Vector{UInt8}; status::Int, headers::Vector{Pair}) :: HTTP.Response\n\nA helper function that can be passed binary data that should be interpreted as JSON.  No conversion is done on the content since it's already in binary format.\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.css","page":"Api","title":"Oxygen.Core.Util.css","text":"css(content::String; status::Int, headers::Vector{Pair}) :: HTTP.Response\n\nA convenience function to return a String that should be interpreted as CSS\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.binary","page":"Api","title":"Oxygen.Core.Util.binary","text":"binary(request::HTTP.Request)\n\nRead the body of a HTTP.Request as a Vector{UInt8}\n\n\n\n\n\nbinary(content::Vector{UInt8}; status::Int, headers::Vector{Pair}) :: HTTP.Response\n\nA convenience function to return a Vector of UInt8 that should be interpreted as binary data\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.@cron","page":"Api","title":"Oxygen.@cron","text":"@cron(expression::String, func::Function)\n\nRegisters a function with a cron expression. This will extract either the function name  or the random Id julia assigns to each lambda function. \n\n\n\n\n\n@cron(expression::String, name::String, func::Function)\n\nThis variation provides way manually \"name\" a registered function. This information  is used by the server on startup to log out all cron jobs.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Oxygen.starttasks","page":"Api","title":"Oxygen.starttasks","text":"starttasks()\n\nStart all background repeat tasks\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.stoptasks","page":"Api","title":"Oxygen.stoptasks","text":"stoptasks()\n\nStop all background repeat tasks\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.cleartasks","page":"Api","title":"Oxygen.cleartasks","text":"cleartasks(ct::ServerContext)\n\nClear any stored repeat task definitions\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.startcronjobs","page":"Api","title":"Oxygen.startcronjobs","text":"startcronjobs()\n\nStart all the cron cronjobs within their own async task. Each individual task will loop conintually  and sleep untill the next time it's suppost to \n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.stopcronjobs","page":"Api","title":"Oxygen.stopcronjobs","text":"stopcronjobs()\n\nStop each background task by toggling a global reference that all cron jobs reference\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.clearcronjobs","page":"Api","title":"Oxygen.clearcronjobs","text":"Clears all cron job defintions\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.router","page":"Api","title":"Oxygen.router","text":"\n\n\n\n","category":"function"},{"location":"api/#Oxygen.internalrequest","page":"Api","title":"Oxygen.internalrequest","text":"internalrequest(req::HTTP.Request; middleware::Vector=[], serialize::Bool=true, catch_errors::Bool=true)\n\nDirectly call one of our other endpoints registered with the router, using your own middleware and bypassing any globally defined middleware\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.Core.Util.redirect","page":"Api","title":"Oxygen.Core.Util.redirect","text":"redirect(path::String; code = 307)\n\nreturn a redirect response \n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.terminate","page":"Api","title":"Oxygen.terminate","text":"terminate(ctx)\n\nGracefully shuts down the webserver\n\n\n\n\n\n","category":"function"},{"location":"api/#Oxygen.resetstate","page":"Api","title":"Oxygen.resetstate","text":"resetstate()\n\nReset all the internal state variables\n\n\n\n\n\n","category":"function"},{"location":"tutorial/oauth2/#OAuth2-with-Umbrella.jl","page":"OAuth2 with Umbrella.jl","title":"OAuth2 with Umbrella.jl","text":"Umbrella.jl is a simple Julia authentication plugin, it supports Google and GitHub OAuth2 with more to come. Umbrella integrates with Julia web framework such as Genie.jl, Oxygen.jl or Mux.jl effortlessly.","category":"section"},{"location":"tutorial/oauth2/#Prerequisite","page":"OAuth2 with Umbrella.jl","title":"Prerequisite","text":"Before using the plugin, you need to obtain OAuth 2 credentials, see Google Identity Step 1, GitHub: Creating an OAuth App for details.","category":"section"},{"location":"tutorial/oauth2/#Installation","page":"OAuth2 with Umbrella.jl","title":"Installation","text":"pkg> add Umbrella","category":"section"},{"location":"tutorial/oauth2/#Basic-Usage","page":"OAuth2 with Umbrella.jl","title":"Basic Usage","text":"Many resources are available describing how OAuth 2 works, please advice OAuth 2.0, Google Identity, or GitHub OAuth 2 for details\n\nFollow the steps below to enable OAuth 2 in your application. ","category":"section"},{"location":"tutorial/oauth2/#1.-Configuration","page":"OAuth2 with Umbrella.jl","title":"1. Configuration","text":"OAuth 2 required parameters such as client_id, client_secret and redirect_uri need to be configured through Configuration.Options. \n\nscopes is a list of resources the application will access on user's behalf, it is vary from one provider to another.\n\nproviderOptions configures the additional parameters at the redirection step, it is dependent on the provider.\n\nconst options = Configuration.Options(;\n    client_id = \"\", # client id from an OAuth 2 provider\n    client_secret = \"\", # secret from an OAuth 2 provider\n    redirect_uri = \"http://localhost:3000/oauth2/google/callback\",\n    success_redirect = \"/protected\",\n    failure_redirect = \"/error\",\n    scopes = [\"profile\", \"openid\", \"email\"],\n    providerOptions = GoogleOptions(access_type=\"online\")\n)\n\ninit function takes the provider and options, then returns an OAuth 2 instance. Available provider values are :google, :github and facebook. This list is growing as more providers are supported.\n\noauth2_instance = init(:google, options)\n\nThe examples will use Oxygen.jl as the web framework, but the concept is the same for other web frameworks.","category":"section"},{"location":"tutorial/oauth2/#2.-Handle-provider-redirection","page":"OAuth2 with Umbrella.jl","title":"2. Handle provider redirection","text":"Create two endpoints,\n\n/ serve the login page which, in this case, is a Google OAuth 2 link.\n/oauth2/google handles redirections to an OAuth 2 server.\n\n@get \"/\" function ()\n  return \"<a href='/oauth2/google'>Authenticate with Google</a>\"\nend\n\n@get \"/oauth2/google\" function ()\n  oauth2_instance.redirect()\nend\n\nredirect function generates the URL using the parameters in step 1, and redirects users to provider's OAuth 2 server to initiate the authentication and authorization process.\n\nOnce the users consent to grant access to one or more scopes requested by the application, OAuth 2 server responds the code for retrieving access token to a callback endpoint.","category":"section"},{"location":"tutorial/oauth2/#3.-Retrieves-tokens","page":"OAuth2 with Umbrella.jl","title":"3. Retrieves tokens","text":"Finally, create the endpoint handling callback from the OAuth 2 server. The path must be identical to the path in redirect_uri from Configuration.Options.\n\ntoken_exchange function performs two actions,\n\nUse code responded by the OAuth 2 server to exchange an access token.\nGet user profile using the access token.\n\nA handler is required for access/refresh tokens and user profile handling.\n\n@get \"/oauth2/google/callback\" function (req)\n  query_params = queryparams(req)\n  code = query_params[\"code\"]\n\n  oauth2_instance.token_exchange(code, function (tokens, user)\n      # handle tokens and user profile here\n    end\n  )\nend","category":"section"},{"location":"tutorial/oauth2/#Full-Example","page":"OAuth2 with Umbrella.jl","title":"Full Example","text":"using Oxygen\nusing Umbrella\nusing HTTP\n\nconst oauth_path = \"/oauth2/google\"\nconst oauth_callback = \"/oauth2/google/callback\"\n\nconst options = Configuration.Options(;\n    client_id=\"\", # client id from Google API Console\n    client_secret=\"\", # secret from Google API Console\n    redirect_uri=\"http://127.0.0.1:8080$(oauth_callback)\",\n    success_redirect=\"/protected\",\n    failure_redirect=\"/no\",\n    scopes=[\"profile\", \"openid\", \"email\"]\n)\n\nconst google_oauth2 = Umbrella.init(:google, options)\n\n@get \"/\" function()\n  return \"<a href='$(oauth_path)'>Authenticate with Google</a>\"\nend\n\n@get oauth_path function()\n  # this handles the Google oauth2 redirect in the background\n  google_oauth2.redirect()\nend\n\n@get oauth_callback function(req)\n  query_params = queryparams(req)\n  code = query_params[\"code\"]\n\n  # handle tokens and user details\n  google_oauth2.token_exchange(code, \n    function (tokens::Google.Tokens, user::Google.User)\n      println(tokens.access_token)\n      println(tokens.refresh_token)\n      println(user.email)\n    end\n  )\nend\n\n@get \"/protected\" function()\n  \"Congrets, You signed in Successfully!\"\nend\n\n# start the web server\nserve()","category":"section"},{"location":"tutorial/query_parameters/#Query-Parameters","page":"Query Parameters","title":"Query Parameters","text":"When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters.\n\nIn the example below, we have two query parameters passed to our request handler\n\ndebug = true \nlimit = 10\n\nhttp://127.0.0.1:8000/echo?debug=true&limit=10\n\nTo show how this works, lets take a look at this route below:\n\n@get \"/echo\" function(req)\n    # the queryparams() function will extract all query paramaters from the url \n    return queryparams(req)\nend\n\nIf we hit this route with a url like the one below we should see the query parameters returned as a JSON object \n\n{\n    \"debug\": \"true\",\n    \"limit\": \"10\"\n}\n\nThe important distinction between query parameters and path parameters is that they are not automatically converted for you. In this example debug & limit are set to a string even though those aren't the \"correct\" data types.","category":"section"},{"location":"tutorial/request_body/#Request-Body","page":"Request Body","title":"Request Body","text":"Whenever you need to send data from a client to your API,  you send it as a request body.\n\nA request body is data sent by the client to your API (usually JSON). A response body is the data your API sends to the client.\n\nRequest bodies are useful when you need to send more complicated information to an API. Imagine we wanted to request an uber/lyft to come pick us up. The app (a client) will have to send a lot of information to make this happen. It'd need to send information about the user (like location data, membership info) and data about the destination. The api in turn will have to figure out pricing, available drivers and potential routes to take. \n\nThe inputs of this api are pretty complicated which means it's a perfect case where we'd want to use the request body to send this information. You could send this kind of information through the URL, but I'd highly recommend you don't. Request bodies can store data in pretty much any format which is a lot more flexible than what a URL can support.","category":"section"},{"location":"tutorial/request_body/#Example","page":"Request Body","title":"Example","text":"The request bodies can be read and converted to a Julia object by using the built-in json() helper function. \n\nstruct Person\n    name::String\n    age::String\nend\n\n@post \"/create/struct\" function(req)\n    # this will convert the request body directly into a Person struct\n    person = json(req, Person)\n    return \"hello $(person.name)!\"\nend\n\n@post \"/create/dict\" function(req)\n    # this will convert the request body into a Julia Dict\n    data = json(req)\n    return \"\"\"hello $(data[\"name\"])!\"\"\"\nend\n\nWhen converting JSON into struct's Oxygen will throw an error if the request body doesn't match the struct, all properties need to be visible and match the right type. \n\nIf you don't pass a struct to convert the JSON into, then it will convert the JSON into a Julia Dictionary. This has the benefit of being able to take JSON of any shape which is helpful when your data can change shape or is unknown. ","category":"section"},{"location":"tutorial/path_parameters/#Path-Parameters","page":"Path Parameters","title":"Path Parameters","text":"You can declare path \"parameters\" or \"variables\" inside your route with braces and those values are passed directly to your request handler. \n\n@get \"/multiply/{a}/{b}\" function(req, a::Float64, b::Float64)\n    return a * b\nend\n\nThe values of {a} & {b} in the path will get passed to the request handler with the parameter with the same name. ","category":"section"},{"location":"tutorial/path_parameters/#Path-parameters-with-types","page":"Path Parameters","title":"Path parameters with types","text":"You can declare the type of a path parameter in the function, using standard Julia type annotations\n\nLet's take a look back at our first example above we have code to add two numbers.\n\n@get \"/multiply/{a}/{b}\" function(req, a::Float64, b::Float64)\n\nIn this line we have our request type, route, and function handler defined. Looking closer at our request handler,  we can see our variables have type annotations attached to them. \n\nOxygen will use any type annotations you give it to try to convert the incoming data into that type.  Granted, these are completely optional, if you leave out the type annotation then Oxygen will  assume it's a string by default. Below is another way to write the same function without type annotations.\n\n@get \"/multiply/{a}/{b}\" function(req, a, b)\n    return parse(Float64, a) * parse(Float64, b)\nend","category":"section"},{"location":"tutorial/path_parameters/#Autogenerated-Docs-and-Path-Types","page":"Path Parameters","title":"Autogenerated Docs & Path Types","text":"And when you open your browser at http://127.0.0.1:8080/docs, you will see the autogenerated interactive documentation for your api. \n\nIf type annotations were provided in the request handler, they will be taken into account  when generating the openapi spec. This means that the generated documentation will know  what the input types will be and will not only show, but enforce those types through the interactive documentation. \n\nPractically, this means that your users will know exactly how to call your endpoint and  your inputs will always remain up to date with the code.  ","category":"section"},{"location":"tutorial/path_parameters/#Additional-Parameter-Type-Support","page":"Path Parameters","title":"Additional Parameter Type Support","text":"Oxygen supports a lot of different path parameter types outside of  Julia's base primitives. More complex types & structs are automatically parsed  and passed to your request handlers.\n\nIn most cases, Oxygen uses the built-in parse() function to parse incoming parameters.  But when the parameter types start getting more complex (eg. Vector{Int64} or a custom struct), then Oxygen assumes the parameter is a JSON string and uses the JSON library  to serialize the parameter into the corresponding type\n\nusing Dates\nusing Oxygen\n\n@enum Fruit apple=1 orange=2 kiwi=3\n\nstruct Person \n  name  :: String \n  age   :: Int8\nend\n\n@get \"/fruit/{fruit}\" function(req, fruit::Fruit)\n  return fruit\nend\n\n@get \"/date/{date}\" function(req, date::Date)\n  return date\nend\n\n@get \"/datetime/{datetime}\" function(req, datetime::DateTime)\n  return datetime\nend\n\n@get \"/complex/{complex}\" function(req, complex::Complex{Float64})\n  return complex\nend\n\n@get \"/list/{list}\" function(req, list::Vector{Float32})\n    return list\nend\n\n@get \"/data/{dict}\" function(req, dict::Dict{String, Any})\n  return dict\nend\n\n@get \"/tuple/{tuple}\" function(req, tuple::Tuple{String, String})\n  return tuple\nend\n\n@get \"/union/{value}\" function(req, value::Union{Bool, String, Float64})\n  return value\nend\n\n@get \"/boolean/{bool}\" function(req, bool::Bool)\n  return bool\nend\n\n@get \"/struct/{person}\" function(req, person::Person)\n  return person\nend\n\n@get \"/float/{float}\" function (req, float::Float32)\n  return float\nend\n\nserve()","category":"section"},{"location":"#Oxygen.jl","page":"Overview","title":"Oxygen.jl","text":"<div>\n  </br>\n  <p align=\"center\"><img src=\"oxygen.png\" width=\"20%\"></p>\n  <p align=\"center\">\n    <strong>A breath of fresh air for programming web apps in Julia.</strong>\n  </p>\n  <p align=\"center\">\n    <a href='https://juliahub.com/ui/Packages/General/Oxygen'><img src='https://juliahub.com/docs/General/Oxygen/stable/version.svg' alt='Version' /></a>\n    <a href='https://oxygenframework.github.io/Oxygen.jl/stable/'><img src='https://img.shields.io/badge/docs-stable-blue.svg' alt='documentation stable' /></a>\n    <a href='https://github.com/OxygenFramework/Oxygen.jl/actions/workflows/ci.yml'><img src='https://github.com/OxygenFramework/Oxygen.jl/actions/workflows/ci.yml/badge.svg' alt='Build Status' /></a>\n    <a href='https://coveralls.io/github/OxygenFramework/Oxygen.jl?branch=master'><img src='https://coveralls.io/repos/github/OxygenFramework/Oxygen.jl/badge.svg?branch=master' alt='Coverage Status' /></a>\n    <!-- <a href='https://codecov.io/gh/OxygenFramework/Oxygen.jl'><img src='https://codecov.io/gh/OxygenFramework/Oxygen.jl/branch/master/graph/badge.svg' alt='Coverage Status' /></a> -->\n  </p>\n</div>","category":"section"},{"location":"#About","page":"Overview","title":"About","text":"Oxygen is a micro-framework built on top of the HTTP.jl library.  Breathe easy knowing you can quickly spin up a web server with abstractions you're already familiar with.","category":"section"},{"location":"#Contact","page":"Overview","title":"Contact","text":"Need Help? Feel free to reach out on our social media channels.\n\n(Image: Chat on Discord)  (Image: Discuss on GitHub)","category":"section"},{"location":"#Features","page":"Overview","title":"Features","text":"Straightforward routing\nReal-time Metrics Dashboard\nAuto-generated swagger documentation\nOut-of-the-box JSON serialization & deserialization (customizable)\nType definition support for path parameters\nRequest Extractors\nApplication Context\nMultiple Instance Support\nMultithreading support\nWebsockets, Streaming, and Server-Sent Events\nCron Scheduling (on endpoints & functions)\nMiddleware chaining (at the application, router, and route levels)\nPrebuilt Middleware (RateLimiter, Cors, BearerAuth)\nStatic & Dynamic file hosting\nHot reloads with Revise.jl\nTemplating Support\nPlotting Support\nProtocol Buffer Support\nRoute tagging\nRepeat tasks","category":"section"},{"location":"#Installation","page":"Overview","title":"Installation","text":"pkg> add Oxygen","category":"section"},{"location":"#Minimalistic-Example","page":"Overview","title":"Minimalistic Example","text":"Create a web-server with very few lines of code\n\nusing Oxygen\nusing HTTP\n\n@get \"/greet\" function(req::HTTP.Request)\n    return \"hello world!\"\nend\n\n# start the web server\nserve()","category":"section"},{"location":"#Handlers","page":"Overview","title":"Handlers","text":"Handlers are used to connect your code to the server in a clean & straightforward way.  They assign a url to a function and invoke the function when an incoming request matches that url.\n\nHandlers can be imported from other modules and distributed across multiple files for better organization and modularity\nAll handlers have equivalent macro & function implementations and support do..end block syntax\nThe type of first argument is used to identify what kind of handler is being registered\nThis package assumes it's a Request handler by default when no type information is provided\n\nThere are 3 types of supported handlers:\n\nRequest Handlers\nStream Handlers\nWebsocket Handlers\n\nusing HTTP\nusing Oxygen\n\n# Request Handler\n@get \"/\" function(req::HTTP.Request)\n    ...\nend\n\n# Stream Handler\n@stream \"/stream\" function(stream::HTTP.Stream)\n    ...\nend\n\n# Websocket Handler\n@websocket \"/ws\" function(ws::HTTP.WebSocket)\n    ...\nend\n\nThey are just functions which means there are many ways that they can be expressed and defined. Below is an example of several different ways you can express and assign a Request handler.\n\n@get \"/greet\" function()\n    \"hello world!\"\nend\n\n@get(\"/gruessen\") do \n    \"Hallo Welt!\"\nend\n\n@get \"/saluer\" () -> begin\n    \"Bonjour le monde!\"\nend\n\n@get \"/saludar\" () -> \"¡Hola Mundo!\"\n@get \"/salutare\" f() = \"ciao mondo!\"\n\n# This function can be declared in another module\nfunction subtract(req, a::Float64, b::Float64)\n  return a - b\nend\n\n# register foreign request handlers like this\n@get \"/subtract/{a}/{b}\" subtract\n\n<details>     <summary><b>More Handler Docs</b></summary>","category":"section"},{"location":"#Request-Handlers","page":"Overview","title":"Request Handlers","text":"Request handlers are used to handle HTTP requests. They are defined using macros or their function equivalents, and accept a HTTP.Request object as the first argument. These handlers support both function and do-block syntax.\n\nThe default Handler when no type information is provided\nRouting Macros: @get, @post, @put, @patch, @delete, @route\nRouting Functions: get(), post(), put(), patch(), delete(), route()","category":"section"},{"location":"#Stream-Handlers","page":"Overview","title":"Stream Handlers","text":"Stream handlers are used to stream data. They are defined using the @stream macro or the stream() function and accept a HTTP.Stream object as the first argument. These handlers support both function and do-block syntax.\n\n@stream and stream() don't require a type definition on the first argument, they assume it's a stream.\nStream handlers can be assigned with standard routing macros & functions: @get, @post, etc\nYou need to explicitly include the type definition so Oxygen can identify this as a Stream handler","category":"section"},{"location":"#Websocket-Handlers","page":"Overview","title":"Websocket Handlers","text":"Websocket handlers are used to handle websocket connections. They are defined using the @websocket macro or the websocket() function and accept a HTTP.WebSocket object as the first argument. These handlers support both function and do-block syntax.\n\n@websocket and websocket() don't require a type definition on the first argument, they assume it's a websocket.\nWebsocket handlers can also be assigned with the @get macro or get() function, because the websocket protocol requires a GET request to initiate the handshake. \nYou need to explicitly include the type definition so Oxygen can identify this as a Websocket handler\n\n</details>","category":"section"},{"location":"#Routing-Macro-and-Function-Syntax","page":"Overview","title":"Routing Macro & Function Syntax","text":"There are two primary ways to register your request handlers: the standard routing macros or the routing functions which utilize the do-block syntax. \n\nFor each routing macro, we now have a an equivalent routing function\n\n@get    -> get()\n@post   -> post()\n@put    -> put()\n@patch  -> patch()\n@delete -> delete()\n@route  -> route()\n\nThe only practical difference between the two is that the routing macros are called during the precompilation stage, whereas the routing functions are only called when invoked. (The routing macros call the routing functions under the hood)\n\n# Routing Macro syntax\n@get \"/add/{x}/{y}\" function(request::HTTP.Request, x::Int, y::Int)\n    x + y\nend\n\n# Routing Function syntax\nget(\"/add/{x}/{y}\") do request::HTTP.Request, x::Int, y::Int\n    x + y\nend","category":"section"},{"location":"#Render-Functions","page":"Overview","title":"Render Functions","text":"Oxygen, by default, automatically identifies the Content-Type of the return value from a request handler when building a Response. This default functionality is quite useful, but it does have an impact on performance. In situations where the return type is known, It's recommended to use one of the pre-existing render functions to speed things up.\n\nHere's a list of the currently supported render functions: html, text, json, file, xml, js, css, binary\n\nBelow is an example of how to use these functions:\n\nusing Oxygen \n\nget(\"/html\") do \n    html(\"<h1>Hello World</h1>\")\nend\n\nget(\"/text\") do \n    text(\"Hello World\")\nend\n\nget(\"/json\") do \n    json(Dict(\"message\" => \"Hello World\"))\nend\n\nserve()\n\nIn most cases, these functions accept plain strings as inputs. The only exceptions are the binary function, which accepts a Vector{UInt8}, and the json function which accepts any serializable type. \n\nEach render function accepts a status and custom headers.\nThe Content-Type and Content-Length headers are automatically set by these render functions","category":"section"},{"location":"#Path-parameters","page":"Overview","title":"Path parameters","text":"Path parameters are declared with braces and are passed directly to your request handler. \n\nusing Oxygen\n\n# use path params without type definitions (defaults to Strings)\n@get \"/add/{a}/{b}\" function(req, a, b)\n    return parse(Float64, a) + parse(Float64, b)\nend\n\n# use path params with type definitions (they are automatically converted)\n@get \"/multiply/{a}/{b}\" function(req, a::Float64, b::Float64)\n    return a * b\nend\n\n# The order of the parameters doesn't matter (just the name matters)\n@get \"/subtract/{a}/{b}\" function(req, b::Int64, a::Int64)\n    return a - b\nend\n\n# start the web server\nserve()","category":"section"},{"location":"#Query-parameters","page":"Overview","title":"Query parameters","text":"Query parameters can be declared directly inside of your handlers signature. Any parameter that isn't mentioned inside the route path is assumed to be a query parameter.\n\nIf a default value is not provided, it's assumed to be a required parameter\n\n@get \"/query\" function(req::HTTP.Request, a::Int, message::String=\"hello world\")\n    return (a, message)\nend\n\nAlternatively, you can use the queryparams() function to extract the raw values from the url as a dictionary. \n\n@get \"/query\" function(req::HTTP.Request)\n    return queryparams(req)\nend","category":"section"},{"location":"#HTML-Forms","page":"Overview","title":"HTML Forms","text":"Use the formdata() function to extract and parse the form data from the body of a request. This function returns a dictionary of key-value pairs from the form\n\nusing Oxygen\n\n# Setup a basic form\n@get \"/\" function()\n    html(\"\"\"\n    <form action=\"/form\" method=\"post\">\n        <label for=\"firstname\">First name:</label><br>\n        <input type=\"text\" id=\"firstname\" name=\"firstname\"><br>\n        <label for=\"lastname\">Last name:</label><br>\n        <input type=\"text\" id=\"lastname\" name=\"lastname\"><br><br>\n        <input type=\"submit\" value=\"Submit\">\n    </form>\n    \"\"\")\nend\n\n# Parse the form data and return it\n@post \"/form\" function(req)\n    data = formdata(req)\n    return data\nend\n\nserve()","category":"section"},{"location":"#Return-JSON","page":"Overview","title":"Return JSON","text":"All objects are automatically deserialized into JSON using the JSON3 library\n\nusing Oxygen\nusing HTTP\n\n@get \"/data\" function(req::HTTP.Request)\n    return Dict(\"message\" => \"hello!\", \"value\" => 99.3)\nend\n\n# start the web server\nserve()","category":"section"},{"location":"#Deserialize-and-Serialize-custom-structs","page":"Overview","title":"Deserialize & Serialize custom structs","text":"Oxygen provides out-of-the-box serialization & deserialization for all objects and structs using the JSON.jl package\n\nusing Oxygen\nusing HTTP\n\nstruct Animal\n    id::Int\n    type::String\n    name::String\nend\n\n@get \"/get\" function(req::HTTP.Request)\n    # serialize struct into JSON automatically\n    return Animal(1, \"cat\", \"whiskers\")\nend\n\n@post \"/echo\" function(req::HTTP.Request)\n    # deserialize JSON from the request body into an Animal struct\n    animal = json(req, Animal)\n    # serialize struct back into JSON automatically\n    return animal\nend\n\n# start the web server\nserve()","category":"section"},{"location":"#Extractors","page":"Overview","title":"Extractors","text":"Oxygen comes with several built-in extractors designed to reduce the amount of boilerplate required to serialize inputs to your handler functions. By simply defining a struct and specifying the data source, these extractors streamline the process of data ingestion & validation through a uniform api.\n\nThe serialized data is accessible through the payload property\nCan be used alongside other parameters and extractors\nDefault values can be assigned when defined with the @kwdef macro\nIncludes both global and local validators\nStruct definitions can be deeply nested\n\nSupported Extractors:\n\nPath - extracts from path parameters\nQuery - extracts from query parameters, \nHeader - extracts from request headers\nForm - extracts form data from the request body\nBody - serializes the entire request body to a given type (String, Float64, etc..)\nProtoBuffer - extracts the ProtoBuf message from the request body (available through a package extension)\nJson - extracts json from the request body\nJsonFragment - extracts a \"fragment\" of the json body using the parameter name to identify and extract the corresponding top-level key","category":"section"},{"location":"#Using-Extractors-and-Parameters","page":"Overview","title":"Using Extractors & Parameters","text":"In this example we show that the Path extractor can be used alongside regular path parameters. This Also works with regular query parameters and the Query extractor.\n\nstruct Add\n    b::Int\n    c::Int\nend\n\n@get \"/add/{a}/{b}/{c}\" function(req, a::Int, pathparams::Path{Add})\n    add = pathparams.payload # access the serialized payload\n    return a + add.b + add.c\nend","category":"section"},{"location":"#Default-Values","page":"Overview","title":"Default Values","text":"Default values can be setup with structs using the @kwdef macro.\n\n@kwdef struct Pet\n    name::String\n    age::Int = 10\nend\n\n@post \"/pet\" function(req, params::Json{Pet})\n    return params.payload # access the serialized payload\nend","category":"section"},{"location":"#Nullable-Types","page":"Overview","title":"Nullable Types","text":"You can indicate that a field may be null by declaring it as a Union type with Nothing.\n\nNote: While the serializer can handle type ::Union{T,Missing} it will fail if a default value of missing provided. Instead use ::Union{T,Nothing} = nothing.\n\n@kwdef struct Pet\n    name::Union{String,Nothing} # Valid\n    surname::Union{String,Nothing} = nothing # Valid\n    eyecolor::Union{ColorStruct, Missing} # Valid \n    coatcolor::Union{ColorStruct,Missing} = missing # Invalid: no schema will be generated for `Pet` \n    age::Int = 10\nend\n","category":"section"},{"location":"#Validation","page":"Overview","title":"Validation","text":"On top of serializing incoming data, you can also define your own validation rules by using the validate function. In the example below we show how to use both global and local validators in your code.\n\nValidators are completely optional\nDuring the validation phase, oxygen will call the global validator before running a local validator.\n\nimport Oxygen: validate\n\nstruct Person\n    name::String\n    age::Int\nend\n\n# Define a global validator \nvalidate(p::Person) = p.age >= 0\n\n# Only the global validator is ran here\n@post \"/person\" function(req, newperson::Json{Person})\n    return newperson.payload\nend\n\n# In this case, both global and local validators are ran (this also makes sure the person is age 21+)\n# You can also use this sytnax instead: Json(Person, p -> p.age >= 21)\n@post \"/adult\" function(req, newperson = Json{Person}(p -> p.age >= 21))\n    return newperson.payload\nend","category":"section"},{"location":"#Application-Context","page":"Overview","title":"Application Context","text":"Most applications at some point will need to rely on some shared global state across the codebase.  This usually comes in the form of a shared database connection pool or some other in memory store.  Oxygen provides a context argument which acts as a free spot for developers to store any objects that  should be available throughout the lifetime of an application.\n\nThere are three primary ways to get access to your application context\n\nInjected into any request handler using the Context struct.\nThe context keyword argument in a function handler\nThrough the context() function \n\nThere are no built-in data race protections, but this is intentional. Not all applications have the same requirements,  so it's up to the developer to decide how to best handle this. For those who need to share mutable state across multiple threads I'd recommend looking into using Actors, Channels, or ReentrantLocks to handle this quickly.\n\nBelow is a simplified example where we store a Person as the application context to show how things are  connected and shared.\n\nusing Oxygen\n\nstruct Person\n    name::String\nend\n\n# The ctx argument here is injected through the Context class\n@get \"/ctx-injection\" function(req, ctx::Context{Person})\n    person :: Person = ctx.payload # access the underlying value\n    return \"Hello $(person.name)!\"\nend\n\n# Access the context through the 'context' keyword argument \n@get \"/ctx-kwarg\" function(req; context)\n    person :: Person = context \n    return \"Hello $(person.name)!\"\nend\n\n# Access context through the 'context()' function\n@get \"/ctx-function\" function(req)\n    person :: Person = context()\n    return \"Hello $(person.name)!\"\nend\n\n# This represents the application context shared between all handlers\nperson = Person(\"John\")\n\n# Here is how we set the application context in our server\nserve(context=person)","category":"section"},{"location":"#Interpolating-variables-into-endpoints","page":"Overview","title":"Interpolating variables into endpoints","text":"You can interpolate variables directly into the paths, which makes dynamically registering routes a breeze \n\n(Thanks to @anandijain for the idea)\n\nusing Oxygen\n\noperations = Dict(\"add\" => +, \"multiply\" => *)\nfor (pathname, operator) in operations\n    @get \"/$pathname/{a}/{b}\" function (req, a::Float64, b::Float64)\n        return operator(a, b)\n    end\nend\n\n# start the web server\nserve()","category":"section"},{"location":"#Routers","page":"Overview","title":"Routers","text":"The router() function is an HOF (higher order function) that allows you to reuse the same path prefix & properties across multiple endpoints. This is helpful when your api starts to grow and you want to keep your path operations organized.\n\nBelow are the arguments the router() function can take:\n\nrouter(prefix::String; tags::Vector, middleware::Vector, interval::Real, cron::String)\n\ntags - are used to organize endpoints in the autogenerated docs\nmiddleware - is used to setup router & route-specific middleware\ninterval - is used to support repeat actions (calling a request handler on a set interval in seconds)\ncron - is used to specify a cron expression that determines when to call the request handler.\n\nusing Oxygen\n\n# Any routes that use this router will be automatically grouped \n# under the 'math' tag in the autogenerated documenation\nmath = router(\"/math\", tags=[\"math\"])\n\n# You can also assign route specific tags\n@get math(\"/multiply/{a}/{b}\", tags=[\"multiplication\"]) function(req, a::Float64, b::Float64)\n    return a * b\nend\n\n@get math(\"/divide/{a}/{b}\") function(req, a::Float64, b::Float64)\n    return a / b\nend\n\nserve()","category":"section"},{"location":"#Cron-Scheduling","page":"Overview","title":"Cron Scheduling","text":"Oxygen comes with a built-in cron scheduling system that allows you to call endpoints and functions automatically when the cron expression matches the current time.\n\nWhen a job is scheduled, a new task is created and runs in the background. Each task uses its given cron expression and the current time to determine how long it needs to sleep before it can execute.\n\nThe cron parser in Oxygen is based on the same specifications as the one used in Spring. You can find more information about this on the Spring Cron Expressions page.","category":"section"},{"location":"#Cron-Expression-Syntax","page":"Overview","title":"Cron Expression Syntax","text":"The following is a breakdown of what each parameter in our cron expression represents. While our specification closely resembles the one defined by Spring, it's not an exact 1-to-1 match.\n\nThe string has six single space-separated time and date fields:\n\n ┌───────────── second (0-59)\n │ ┌───────────── minute (0 - 59)\n │ │ ┌───────────── hour (0 - 23)\n │ │ │ ┌───────────── day of the month (1 - 31)\n │ │ │ │ ┌───────────── month (1 - 12) (or JAN-DEC)\n │ │ │ │ │ ┌───────────── day of the week (1 - 7)\n │ │ │ │ │ │          (Monday is 1, Tue is 2... and Sunday is 7)\n │ │ │ │ │ │\n * * * * * *\n\nPartial expressions are also supported, which means that subsequent expressions can be left out (they are defaulted to '*'). \n\n# In this example we see only the `seconds` part of the expression is defined. \n# This means that all following expressions are automatically defaulted to '*' expressions\n@cron \"*/2\" function()\n    println(\"runs every 2 seconds\")\nend","category":"section"},{"location":"#Scheduling-Endpoints","page":"Overview","title":"Scheduling Endpoints","text":"The router() function has a keyword argument called cron, which accepts a cron expression that determines when an endpoint is called. Just like the other keyword arguments, it can be reused by endpoints that share routers or be overridden by inherited endpoints.\n\n# execute at 8, 9 and 10 o'clock of every day.\n@get router(\"/cron-example\", cron=\"0 0 8-10 * * *\") function(req)\n    println(\"here\")\nend\n\n# execute this endpoint every 5 seconds (whenever current_seconds % 5 == 0)\nevery5 = router(\"/cron\", cron=\"*/5\")\n\n# this endpoint inherits the cron expression\n@get every5(\"/first\") function(req)\n    println(\"first\")\nend\n\n# Now this endpoint executes every 2 seconds ( whenever current_seconds % 2 == 0 ) instead of every 5\n@get every5(\"/second\", cron=\"*/2\") function(req)\n    println(\"second\")\nend","category":"section"},{"location":"#Scheduling-Functions","page":"Overview","title":"Scheduling Functions","text":"In addition to scheduling endpoints, you can also use the new @cron macro to schedule functions. This is useful if you want to run code at specific times without making it visible or callable in the API.\n\n@cron \"*/2\" function()\n    println(\"runs every 2 seconds\")\nend\n\n@cron \"0 0/30 8-10 * * *\" function()\n  println(\"runs at 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day\")\nend","category":"section"},{"location":"#Starting-and-Stopping-Cron-Jobs","page":"Overview","title":"Starting & Stopping Cron Jobs","text":"When you run serve() or serveparallel(), all registered cron jobs are automatically started. If the server is stopped or killed, all running jobs will also be terminated. You can stop the server and all repeat tasks and cron jobs by calling the terminate() function or manually killing the server with ctrl+C.\n\nIn addition, Oxygen provides utility functions to manually start and stop cron jobs: startcronjobs() and stopcronjobs(). These functions can be used outside of a web server as well.","category":"section"},{"location":"#Repeat-Tasks","page":"Overview","title":"Repeat Tasks","text":"Repeat tasks provide a simple api to run a function on a set interval. \n\nThere are two ways to register repeat tasks: \n\nThrough the interval parameter in a router()\nUsing the @repeat macro\n\nIt's important to note that request handlers that use this property can't define additional function parameters outside of the default HTTP.Request parameter.\n\nIn the example below, the /repeat/hello endpoint is called every 0.5 seconds and \"hello\" is printed to the console each time.\n\nThe router() function has an interval parameter which is used to call a request handler on a set interval (in seconds). \n\nusing Oxygen\n\ntaskrouter = router(\"/repeat\", interval=0.5, tags=[\"repeat\"])\n\n@get taskrouter(\"/hello\") function()\n    println(\"hello\")\nend\n\n# you can override properties by setting route specific values \n@get taskrouter(\"/bonjour\", interval=1.5) function()\n    println(\"bonjour\")\nend\n\nserve()\n\nBelow is an example of how to register a repeat task outside of the router\n\n@repeat 1.5 function()\n    println(\"runs every 1.5 seconds\")\nend\n\n# you can also \"name\" a repeat task \n@repeat 5 \"every-five\" function()\n    println(\"runs every 5 seconds\")\nend\n\nWhen the server is ran, all tasks are started automatically. But the module also provides utilities to have more fine-grained control over the running tasks using the following functions: starttasks(), stoptasks(), and cleartasks()","category":"section"},{"location":"#Hot-reloads-with-Revise","page":"Overview","title":"Hot reloads with Revise","text":"Oxygen can integrate with Revise to provide hot reloads, speeding up development. Since Revise recommends keeping all code to be revised in a package, you first need to move to this type of a layout.\n\nFirst make sure your Project.toml has the required fields such as name to work on a package rather than a project.\n\nNext, write the main code for you routes in a module src/MyModule.jl:\n\nmodule MyModule\n\nusing Oxygen; @oxidize\n\n@get \"/greet\" function(req::HTTP.Request)\n    return \"hello world!\"\nend\n\nend\n\nThen you can make a debug.jl entrypoint script:\n\nusing Revise\nusing Oxygen\nusing MyModule\n\nMyModule.serve(revise=:eager)\n\nThe revise option can also be set to :lazy, in which case revisions will always be left to just before a request is served, rather than being attempted eagerly when source files change on disk.\n\nNote that you should run another entrypoint script without Revise in production.","category":"section"},{"location":"#Multiple-Instances","page":"Overview","title":"Multiple Instances","text":"In some advanced scenarios, you might need to spin up multiple web severs within the same module on different ports. Oxygen provides both a static and dynamic way to create multiple instances of a web server.\n\nAs a general rule of thumb, if you know how many instances you need ahead of time it's best to go with the static approach.","category":"section"},{"location":"#Static:-multiple-instance's-with-@oxidize","page":"Overview","title":"Static: multiple instance's with @oxidize","text":"Oxygen provides a new macro which makes it possible to setup and run multiple instances. It generates methods and binds them to a new internal state for the current module. \n\nIn the example below, two simple servers are defined within modules A and B and are started in the parent module. Both modules contain all of the functions exported from Oxygen which can be called directly as shown below.\n\nmodule A\n    using Oxygen; @oxidize\n\n    get(\"/\") do\n        text(\"server A\")\n    end\nend\n\nmodule B\n    using Oxygen; @oxidize\n\n    get(\"/\") do\n        text(\"server B\")\n    end\nend\n\ntry \n    # start both instances\n    A.serve(port=8001, async=true)\n    B.serve(port=8002, async=false)\nfinally\n    # shut down if we `Ctrl+C`\n    A.terminate()\n    B.terminate()\nend","category":"section"},{"location":"#Dynamic:-multiple-instance's-with-instance()","page":"Overview","title":"Dynamic: multiple instance's with instance()","text":"The instance function helps you create a completely independent instance of an Oxygen web server at runtime. It works by dynamically creating a julia module at runtime and loading the Oxygen code within it.\n\nAll of the same methods from Oxygen are available under the named instance. In the example below we can use the get, and serve by simply using dot syntax on the app1 variable to access the underlying methods.\n\nusing Oxygen\n\n######### Setup the first app #########\n\napp1 = instance()\n\napp1.get(\"/\") do\n    text(\"server A\")\nend\n\n######### Setup the second app #########\n\napp2 = instance()\n\napp2.get(\"/\") do\n    text(\"server B\")\nend\n\n######### Start both instances #########\n\ntry \n    # start both servers together\n    app1.serve(port=8001, async=true)\n    app2.serve(port=8002)\nfinally\n    # clean it up\n    app1.terminate()\n    app2.terminate()\nend","category":"section"},{"location":"#Multithreading-and-Parallelism","page":"Overview","title":"Multithreading & Parallelism","text":"For scenarios where you need to handle higher amounts of traffic, you can run Oxygen in a  multithreaded mode. In order to utilize this mode, julia must have more than 1 thread to work with. You can start a julia session with 4 threads using the command below\n\njulia --threads 4\n\nserveparallel() Starts the webserver in streaming mode and handles requests in a cooperative multitasking approach. This function uses Threads.@spawn to schedule a new task on any available thread. Meanwhile, @async is used inside this task when calling each request handler. This allows the task to yield during I/O operations.\n\nusing Oxygen\nusing Base.Threads\n\nx = Atomic{Int64}(0);\n\n@get \"/show\" function()\n    return x\nend\n\n@get \"/increment\" function()\n    atomic_add!(x, 1)\n    return x\nend\n\n# start the web server in parallel mode\nserveparallel()","category":"section"},{"location":"#Protocol-Buffers","page":"Overview","title":"Protocol Buffers","text":"Oxygen includes an extension for the ProtoBuf.jl package. This extension provides a protobuf() function, simplifying the process of working with Protocol Buffers in the context of web server. For a better understanding of this package, please refer to its official documentation.\n\nThis function has overloads for the following scenarios:\n\nDecoding a protobuf message from the body of an HTTP request.\nEncoding a protobuf message into the body of an HTTP request.\nEncoding a protobuf message into the body of an HTTP response.\n\nusing HTTP\nusing ProtoBuf\nusing Oxygen\n\n# The generated classes need to be created ahead of time (check the protobufs)\ninclude(\"people_pb.jl\");\nusing .people_pb: People, Person\n\n# Decode a Protocol Buffer Message \n@post \"/count\" function(req::HTTP.Request)\n    # decode the request body into a People object\n    message = protobuf(req, People)\n    # count the number of Person objects\n    return length(message.people)\nend\n\n# Encode & Return Protocol Buffer message\n@get \"/get\" function()\n    message = People([\n        Person(\"John Doe\", 20),\n        Person(\"Alice\", 30),\n        Person(\"Bob\", 35)\n    ])\n    # seralize the object inside the body of a HTTP.Response\n    return protobuf(message)\nend\n\nThe following is an example of a schema that was used to create the necessary Julia bindings. These bindings allow for the encoding and decoding of messages in the above example.\n\nsyntax = \"proto3\";\nmessage Person {\n    string name = 1;\n    sint32 age = 2;\n}\nmessage People {\n    repeated Person people = 1;\n}","category":"section"},{"location":"#Plotting","page":"Overview","title":"Plotting","text":"Oxygen is equipped with several package extensions that enhance its plotting capabilities. These extensions make it easy to return plots directly from request handlers. All operations are performed in-memory using an IOBuffer and return a HTTP.Response\n\nSupported Packages and their helper utils:\n\nCairoMakie.jl: png, svg, pdf, html\nWGLMakie.jl: html\nBonito.jl: html","category":"section"},{"location":"#CairoMakie.jl","page":"Overview","title":"CairoMakie.jl","text":"using CairoMakie: heatmap\nusing Oxygen\n\n@get \"/cairo\" function()\n    fig, ax, pl = heatmap(rand(50, 50))\n    png(fig)\nend\n\nserve()","category":"section"},{"location":"#WGLMakie.jl","page":"Overview","title":"WGLMakie.jl","text":"using Bonito\nusing WGLMakie: heatmap\nusing Oxygen\nusing Oxygen: html # Bonito also exports html\n\n@get \"/wgl\" function()\n    fig = heatmap(rand(50, 50))\n    html(fig)\nend\n\nserve()","category":"section"},{"location":"#Bonito.jl","page":"Overview","title":"Bonito.jl","text":"using Bonito\nusing WGLMakie: heatmap\nusing Oxygen\nusing Oxygen: html # Bonito also exports html\n\n@get \"/bonito\" function()\n    app = App() do\n        return DOM.div(\n            DOM.h1(\"Random 50x50 Heatmap\"), \n            DOM.div(heatmap(rand(50, 50)))\n        )\n    end\n    return html(app)\nend\n\nserve()","category":"section"},{"location":"#Templating","page":"Overview","title":"Templating","text":"Rather than building an internal engine for templating or adding additional dependencies, Oxygen  provides two package extensions to support Mustache.jl and OteraEngine.jl templates.\n\nOxygen provides a simple wrapper api around both packages that makes it easy to render templates from strings, templates, and files. This wrapper api returns a render function which accepts a dictionary of inputs to fill out the template.\n\nIn all scenarios, the rendered template is returned inside a HTTP.Response object ready to get served by the api. By default, the mime types are auto-detected either by looking at the content of the template or the extension name on the file. If you know the mime type you can pass it directly through the mime_type keyword argument to skip the detection process.","category":"section"},{"location":"#Mustache-Templating","page":"Overview","title":"Mustache Templating","text":"Please take a look at the Mustache.jl documentation to learn the full capabilities of the package\n\nExample 1: Rendering a Mustache Template from a File\n\nusing Mustache\nusing Oxygen\n\n# Load the Mustache template from a file and create a render function\nrender = mustache(\"./templates/greeting.txt\", from_file=true)\n\n@get \"/mustache/file\" function()\n    data = Dict(\"name\" => \"Chris\")\n    return render(data)  # This will return an HTML.Response with the rendered template\nend\n\nExample 2: Specifying MIME Type for a plain string Mustache Template\n\nusing Mustache\nusing Oxygen\n\n# Define a Mustache template (both plain strings and mustache templates are supported)\ntemplate_str = \"Hello, {{name}}!\"\n\n# Create a render function, specifying the MIME type as text/plain\nrender = mustache(template_str, mime_type=\"text/plain\") # mime_type keyword arg is optional \n\n@get \"/plain/text\" function()\n    data = Dict(\"name\" => \"Chris\")\n    return render(data)  # This will return a plain text response with the rendered template\nend","category":"section"},{"location":"#Otera-Templating","page":"Overview","title":"Otera Templating","text":"Please take a look at the OteraEngine.jl documentation to learn the full capabilities of the package\n\nExample 1: Rendering an Otera Template with Logic and Loops\n\nusing OteraEngine\nusing Oxygen\n\n# Define an Otera template\ntemplate_str = \"\"\"\n<html>\n    <head><title>{{ title }}</title></head>\n    <body>\n        {% for name in names %}\n        Hello {{ name }}<br>\n        {% end %}\n    </body>\n</html>\n\"\"\"\n\n# Create a render function for the Otera template\nrender = otera(template_str)\n\n@get \"/otera/loop\" function()\n    data = Dict(\"title\" => \"Greetings\", \"names\" => [\"Alice\", \"Bob\", \"Chris\"])\n    return render(data)  # This will return an HTML.Response with the rendered template\nend\n\nIn this example, an Otera template is defined with a for-loop that iterates over a list of names, greeting each name.\n\nExample 2: Running Julia Code in Otera Template\n\nusing OteraEngine\nusing Oxygen\n\n# Define an Otera template with embedded Julia code\ntemplate_str = \"\"\"\nThe square of {{ number }} is {< number^2 >}.\n\"\"\"\n\n# Create a render function for the Otera template\nrender = otera(template_str)\n\n@get \"/otera/square\" function()\n    data = Dict(\"number\" => 5)\n    return render(data)  # This will return an HTML.Response with the rendered template\nend\n\n\nIn this example, an Otera template is defined with embedded Julia code that calculates the square of a given number. ","category":"section"},{"location":"#Mounting-Static-Files","page":"Overview","title":"Mounting Static Files","text":"You can mount static files using this handy function which recursively searches a folder for files and mounts everything. All files are  loaded into memory on startup.\n\nusing Oxygen\n\n# mount all files inside the \"content\" folder under the \"/static\" path\nstaticfiles(\"content\", \"static\")\n\n# start the web server\nserve()","category":"section"},{"location":"#Mounting-Dynamic-Files","page":"Overview","title":"Mounting Dynamic Files","text":"Similar to staticfiles, this function mounts each path and re-reads the file for each request. This means that any changes to the files after the server has started will be displayed.\n\nusing Oxygen\n\n# mount all files inside the \"content\" folder under the \"/dynamic\" path\ndynamicfiles(\"content\", \"dynamic\")\n\n# start the web server\nserve()","category":"section"},{"location":"#Performance-Tips","page":"Overview","title":"Performance Tips","text":"Disabling the internal logger can provide some massive performance gains, which can be helpful in some scenarios. Anecdotally, i've seen a 2-3x speedup in serve() and a 4-5x speedup in serveparallel() performance.\n\n# This is how you disable internal logging in both modes\nserve(access_log=nothing)\nserveparallel(access_log=nothing)","category":"section"},{"location":"#Logging","page":"Overview","title":"Logging","text":"Oxygen provides a default logging format but allows you to customize the format using the access_log parameter. This functionality is available in both the serve() and serveparallel() functions.\n\nYou can read more about the logging options here\n\n# Uses the default logging format\nserve()\n\n# Customize the logging format \nserve(access_log=logfmt\"[$time_iso8601] \\\"$request\\\" $status\")\n\n# Disable internal request logging \nserve(access_log=nothing)","category":"section"},{"location":"#Middleware","page":"Overview","title":"Middleware","text":"Middleware functions make it easy to create custom workflows to intercept all incoming requests and outgoing responses. They are executed in the same order they are passed in (from left to right).\n\nThey can be set at the application, router, and route layer with the middleware keyword argument. All middleware is additive and any middleware defined in these layers will be combined and executed.\n\nMiddleware will always be executed in the following order:\n\napplication -> router -> route\n\nNow lets see some middleware in action:\n\nusing Oxygen\nusing HTTP\n\nconst CORS_HEADERS = [\n    \"Access-Control-Allow-Origin\" => \"*\",\n    \"Access-Control-Allow-Headers\" => \"*\",\n    \"Access-Control-Allow-Methods\" => \"POST, GET, OPTIONS\"\n]\n\n# https://juliaweb.github.io/HTTP.jl/stable/examples/#Cors-Server\nfunction CorsMiddleware(handler)\n    return function(req::HTTP.Request)\n        println(\"CORS middleware\")\n        # determine if this is a pre-flight request from the browser\n        if HTTP.method(req)==\"OPTIONS\"\n            return HTTP.Response(200, CORS_HEADERS)  \n        else \n            return handler(req) # passes the request to the AuthMiddleware\n        end\n    end\nend\n\nfunction AuthMiddleware(handler)\n    return function(req::HTTP.Request)\n        println(\"Auth middleware\")\n        # ** NOT an actual security check ** #\n        if !HTTP.headercontains(req, \"Authorization\", \"true\")\n            return HTTP.Response(403)\n        else \n            return handler(req) # passes the request to your application\n        end\n    end\nend\n\nfunction middleware1(handle)\n    function(req)\n        println(\"middleware1\")\n        handle(req)\n    end\nend\n\nfunction middleware2(handle)\n    function(req)\n        println(\"middleware2\")\n        handle(req)\n    end\nend\n\n# set middleware at the router level\nmath = router(\"math\", middleware=[middleware1])\n\n# set middleware at the route level \n@get math(\"/divide/{a}/{b}\", middleware=[middleware2]) function(req, a::Float64, b::Float64)\n    return a / b\nend\n\n# set application level middleware\nserve(middleware=[CorsMiddleware, AuthMiddleware])","category":"section"},{"location":"#Built-in-Middleware","page":"Overview","title":"Built-in Middleware","text":"Oxygen ships with some prebuilt middleware functions so you can easily integrate bearer auth, rate limiting and CORS support to your app. You can add these at the application, router, or route level in your app through the middleware keyword.","category":"section"},{"location":"#RateLimiter","page":"Overview","title":"RateLimiter","text":"The RateLimiter middleware lets you set a cap on how many requests each client IP can make in a given time window. It's perfect for public endpoints, login routes, or anywhere you want to keep things smooth and prevent brute-force attacks. \n\nThe rate limiting is completely based on the req.context[:ip] property that's added to all requests. If you use proxies or services like cloudflare that intercept requests, you'll need to parse out the actual caller's IP from the headers and reassign the ip property on the request.context object.\n\nExample:\n\n# Limit each client to 50 requests every 3 seconds\nserve(middleware=[RateLimiter(rate_limit=50, window_period=Second(3))])\n\nKeyword Arguments:\n\nrate_limit::Int: Maximum number of requests allowed per IP within the window period. Default is 100.\nwindow_period::Period: Time window for rate limiting. Default is 1 minute.\ncleanup_period::Period: Interval for running the background cleanup task. Default is 10 minutes.\ncleanup_threshold::Period: Minimum age of inactive IP entries before deletion during cleanup. Default is 10 minutes.\n\n","category":"section"},{"location":"#BearerAuth","page":"Overview","title":"BearerAuth","text":"In most serious applications, you'll find yourself needing to add some layer of authentication to your web app. In most cases this means passing an Authorization header, extracting the token, and then validating it either against your custom oauth server or some external service. \n\nAfter authenticating a user, you'll typically want this object readily available to most if not all routes in your application, so your routes don't need to revalidate the user more than once.\n\nThe BearerAuth middleware does exactly this and extracts the bearer token from the authorization header and passes it to your custom function. If the token's good, your handler runs; if not, the request gets bounced.\n\nExample:\n\n# Your function will need to perform actual token validation \nfunction validate_token(token::String)\n    # return the user object \n    return Dict(\"name\" => \"joe\")\nend\n\n# Only let requests with a valid token through\nserve(middleware=[BearerAuth(validate_token)])\n\nParameters:\n\nvalidate_token: Your function for checking if a token is legit. Return user info if it's good, or nothing or missing if not.\n\nKeyword Arguments:\n\nheader: The name of the header to check for the token (defaults to \"Authorization\").\nscheme: The authentication scheme prefix in the header (defaults to \"Bearer\").\n\n","category":"section"},{"location":"#CORS","page":"Overview","title":"CORS","text":"The Cors middleware handles Cross-Origin Resource Sharing (CORS) for your API. It sets the right headers and responds to preflight OPTIONS requests, so browsers can safely call your endpoints from other domains. Just configure your policy with keyword arguments and Oxygen will do the rest.\n\nExample:\n\n# Let any origin connect and expose a custom header\nserve(middleware=[Cors(allowed_origins=\"*\")])\n\nallowed_origins: Value for Access-Control-Allow-Origin (default: \"*\").\nallowed_headers: Value for Access-Control-Allow-Headers (default: \"*\").\nallowed_methods: Value for Access-Control-Allow-Methods (default: \"GET, POST, OPTIONS\").\nallow_credentials: If true, adds Access-Control-Allow-Credentials: true.\nmax_age: If set, adds Access-Control-Max-Age header.\nextra_headers: Vector of additional key-value pairs to be added as extra CORS headers.\n\n","category":"section"},{"location":"#Bringing-it-all-together","page":"Overview","title":"Bringing it all together","text":"In a more real-world example, you'll want to utilize all three of these together\n\nCors - Ensure the caller's domain is allowed to call this server\nRateLimiter - Places a rate-limit limit on the caller's ip to prevent abuse\nBearerAuth - See if the current user has access to the api\n\nExample:\n\n# Mix CORS, rate limiting, and auth for a super secure API\nserve(middleware=[Cors(), RateLimiter(), BearerAuth(validate_token)])\n\nAs a reminder, you can use RateLimiter and BearerAuth middleware on the router and route level to have more fine grained limits and rates on specific endpoints / resources.\n\nExample:\n\n\n# Your function will need to perform actual token validation \nfunction validate_token(token::String)\n    # validate the token and lookup the user object\n    # return the user object \n    return Dict(\"name\" => \"joe\")\nend\n\nprotected = router(\"/protected\", middleware=[RateLimiter(rate_limit=50), BearerAuth(validate_token)])\n\n# This route is protected behind both the global middlewware and a lower rate limit and the token bearer authentication\n@get protected(\"/greet\") function(req)\n    name = req.context[:user][\"name\"]\n    return text(\"hello $(name)!\")\nend\n\n# This route is protected just by the global middleware\n@get \"/\" function()\n    return text(\"welcome to the server\")\nend\n\n# Mix CORS, rate limiting, and auth for a super secure API\nserve(middleware=[Cors(), RateLimiter(rate_limit=100)])","category":"section"},{"location":"#Custom-Response-Serializers","page":"Overview","title":"Custom Response Serializers","text":"If you don't want to use Oxygen's default response serializer, you can turn it off and add your own! Just create your own special middleware function to serialize the response and add it at the end of your own middleware chain. \n\nBoth serve() and serveparallel() have a serialize keyword argument which can toggle off the default serializer.\n\nusing Oxygen\nusing HTTP\nusing JSON\n\n@get \"/divide/{a}/{b}\" function(req::HTTP.Request, a::Float64, b::Float64)\n    return a / b\nend\n\n# This is just a regular middleware function\nfunction myserializer(handle)\n    function(req)\n        try\n          response = handle(req)\n          # convert all responses to JSON\n          return HTTP.Response(200, [], body=JSON.json(response)) \n        catch error \n            @error \"ERROR: \" exception=(error, catch_backtrace())\n            return HTTP.Response(500, \"The Server encountered a problem\")\n        end \n    end\nend\n\n# make sure 'myserializer' is the last middleware function in this list\nserve(middleware=[myserializer], serialize=false)","category":"section"},{"location":"#Autogenerated-Docs-with-Swagger","page":"Overview","title":"Autogenerated Docs with Swagger","text":"Swagger documentation is automatically generated for each route you register in your application. Only the route name, parameter types, and 200 & 500 responses are automatically created for you by default. \n\nYou can view your generated documentation at /docs, and the schema can be found under /docs/schema. Both of these values can be changed to whatever you want using the configdocs() function. You can also opt out of autogenerated docs entirely by calling the disabledocs() function  before starting your application. \n\nTo add additional details you can either use the built-in mergeschema() or setschema() functions to directly modify the schema yourself or merge the generated schema from the SwaggerMarkdown.jl package (I'd recommend the latter)\n\nBelow is an example of how to merge the schema generated from the SwaggerMarkdown.jl package.\n\nusing Oxygen\nusing SwaggerMarkdown\n\n# Here's an example of how you can merge autogenerated docs from SwaggerMarkdown.jl into your api\n@swagger \"\"\"\n/divide/{a}/{b}:\n  get:\n    description: Return the result of a / b\n    parameters:\n      - name: a\n        in: path\n        required: true\n        description: this is the value of the numerator \n        schema:\n          type : number\n    responses:\n      '200':\n        description: Successfully returned an number.\n\"\"\"\n@get \"/divide/{a}/{b}\" function (req, a::Float64, b::Float64)\n    return a / b\nend\n\n# title and version are required\ninfo = Dict(\"title\" => \"My Demo Api\", \"version\" => \"1.0.0\")\nopenApi = OpenAPI(\"3.0\", info)\nswagger_document = build(openApi)\n  \n# merge the SwaggerMarkdown schema with the internal schema\nmergeschema(swagger_document)\n\n# start the web server\nserve()\n\nBelow is an example of how to manually modify the schema\n\nusing Oxygen\nusing SwaggerMarkdown\n\n# Only the basic information is parsed from this route when generating docs\n@get \"/multiply/{a}/{b}\" function (req, a::Float64, b::Float64)\n    return a * b\nend\n\n# Here's an example of how to update a part of the schema yourself\nmergeschema(\"/multiply/{a}/{b}\", \n  Dict(\n    \"get\" => Dict(\n      \"description\" => \"return the result of a * b\"\n    )\n  )\n)\n\n# Here's another example of how to update a part of the schema yourself, but this way allows you to modify other properties defined at the root of the schema (title, summary, etc.)\nmergeschema(\n  Dict(\n    \"paths\" => Dict(\n      \"/multiply/{a}/{b}\" => Dict(\n        \"get\" => Dict(\n          \"description\" => \"return the result of a * b\"\n        )\n      )\n    )\n  )\n)","category":"section"},{"location":"#API-Reference-(macros)","page":"Overview","title":"API Reference (macros)","text":"","category":"section"},{"location":"#@get,-@post,-@put,-@patch,-@delete","page":"Overview","title":"@get, @post, @put, @patch, @delete","text":"  @get(path, func)\n\nParameter Type Description\npath string or router() Required. The route to register\nfunc function Required. The request handler for this route\n\nUsed to register a function to a specific endpoint to handle that corresponding type of request","category":"section"},{"location":"#@route","page":"Overview","title":"@route","text":"  @route(methods, path, func)\n\nParameter Type Description\nmethods array Required. The types of HTTP requests to register to this route\npath string or router() Required. The route to register\nfunc function Required. The request handler for this route\n\nLow-level macro that allows a route to be handle multiple request types","category":"section"},{"location":"#staticfiles","page":"Overview","title":"staticfiles","text":"  staticfiles(folder, mount)\n\nParameter Type Description\nfolder string Required. The folder to serve files from\nmountdir string The root endpoint to mount files under (default is \"static\")\nset_headers function Customize the http response headers when returning these files\nloadfile function Customize behavior when loading files\n\nServe all static files within a folder. This function recursively searches a directory and mounts all files under the mount directory using their relative paths.","category":"section"},{"location":"#dynamicfiles","page":"Overview","title":"dynamicfiles","text":"  dynamicfiles(folder, mount)\n\nParameter Type Description\nfolder string Required. The folder to serve files from\nmountdir string The root endpoint to mount files under (default is \"static\")\nset_headers function Customize the http response headers when returning these files\nloadfile function Customize behavior when loading files\n\nServe all static files within a folder. This function recursively searches a directory and mounts all files under the mount directory using their relative paths. The file is loaded on each request, potentially picking up any file changes.","category":"section"},{"location":"#Request-helper-functions","page":"Overview","title":"Request helper functions","text":"","category":"section"},{"location":"#html()","page":"Overview","title":"html()","text":"  html(content, status, headers)\n\nParameter Type Description\ncontent string Required. The string to be returned as HTML\nstatus integer The HTTP response code (default is 200)\nheaders dict The headers for the HTTP response (default has content-type header set to \"text/html; charset=utf-8\")\n\nHelper function to designate when content should be returned as HTML","category":"section"},{"location":"#queryparams()","page":"Overview","title":"queryparams()","text":"  queryparams(request)\n\nParameter Type Description\nreq HTTP.Request Required. The HTTP request object\n\nReturns the query parameters from a request as a Dict()","category":"section"},{"location":"#Body-Functions","page":"Overview","title":"Body Functions","text":"","category":"section"},{"location":"#text()","page":"Overview","title":"text()","text":"  text(request)\n\nParameter Type Description\nreq HTTP.Request Required. The HTTP request object\n\nReturns the body of a request as a string","category":"section"},{"location":"#binary()","page":"Overview","title":"binary()","text":"  binary(request)\n\nParameter Type Description\nreq HTTP.Request Required. The HTTP request object\n\nReturns the body of a request as a binary file (returns a vector of UInt8s)","category":"section"},{"location":"#json()","page":"Overview","title":"json()","text":"  json(request, class_type)\n\nParameter Type Description\nreq HTTP.Request Required. The HTTP request object\nclass_type struct A struct to deserialize a JSON object into\n\nDeserialize the body of a request into a julia struct","category":"section"},{"location":"tutorial/cron_scheduling/#Cron-Scheduling","page":"Cron Scheduling","title":"Cron Scheduling","text":"Oxygen comes with a built-in cron scheduling system that allows you to call endpoints and functions automatically when the cron expression matches the current time.\n\nWhen a job is scheduled, a new task is created and runs in the background. Each task uses its given cron expression and the current time to determine how long it needs to sleep before it can execute.\n\nThe cron parser in Oxygen is based on the same specifications as the one used in Spring. You can find more information about this on the Spring Cron Expressions page.","category":"section"},{"location":"tutorial/cron_scheduling/#Cron-Expression-Syntax","page":"Cron Scheduling","title":"Cron Expression Syntax","text":"The following is a breakdown of what each parameter in our cron expression represents. While our specification closely resembles the one defined by Spring, it's not an exact 1-to-1 match.\n\nThe string has six single space-separated time and date fields:\n\n ┌───────────── second (0-59)\n │ ┌───────────── minute (0 - 59)\n │ │ ┌───────────── hour (0 - 23)\n │ │ │ ┌───────────── day of the month (1 - 31)\n │ │ │ │ ┌───────────── month (1 - 12) (or JAN-DEC)\n │ │ │ │ │ ┌───────────── day of the week (1 - 7)\n │ │ │ │ │ │          (Monday is 1, Tue is 2... and Sunday is 7)\n │ │ │ │ │ │\n * * * * * *\n\nPartial expressions are also supported, which means that subsequent expressions can be left out (they are defaulted to '*'). \n\n# In this example we see only the `seconds` part of the expression is defined. \n# This means that all following expressions are automatically defaulted to '*' expressions\n@cron \"*/2\" function()\n    println(\"runs every 2 seconds\")\nend","category":"section"},{"location":"tutorial/cron_scheduling/#Scheduling-Endpoints","page":"Cron Scheduling","title":"Scheduling Endpoints","text":"The router() function has a keyword argument called cron, which accepts a cron expression that determines when an endpoint is called. Just like the other keyword arguments, it can be reused by endpoints that share routers or be overridden by inherited endpoints.\n\n# execute at 8, 9 and 10 o'clock of every day.\n@get router(\"/cron-example\", cron=\"0 0 8-10 * * *\") function(req)\n    println(\"here\")\nend\n\n# execute this endpoint every 5 seconds (whenever current_seconds % 5 == 0)\nevery5 = router(\"/cron\", cron=\"*/5\")\n\n# this endpoint inherits the cron expression\n@get every5(\"/first\") function(req)\n    println(\"first\")\nend\n\n# Now this endpoint executes every 2 seconds ( whenever current_seconds % 2 == 0 ) instead of every 5\n@get every5(\"/second\", cron=\"*/2\") function(req)\n    println(\"second\")\nend","category":"section"},{"location":"tutorial/cron_scheduling/#Scheduling-Functions","page":"Cron Scheduling","title":"Scheduling Functions","text":"In addition to scheduling endpoints, you can also use the new @cron macro to schedule functions. This is useful if you want to run code at specific times without making it visible or callable in the API.\n\n@cron \"*/2\" function()\n    println(\"runs every 2 seconds\")\nend\n\n@cron \"0 0/30 8-10 * * *\" function()\n  println(\"runs at 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day\")\nend","category":"section"},{"location":"tutorial/cron_scheduling/#Starting-and-Stopping-Cron-Jobs","page":"Cron Scheduling","title":"Starting & Stopping Cron Jobs","text":"When you run serve() or serveparallel(), all registered cron jobs are automatically started. If the server is stopped or killed, all running jobs will also be terminated. You can stop the server and all repeat tasks and cron jobs by calling the terminate() function or manually killing the server with ctrl+C.\n\nIn addition, Oxygen provides utility functions to manually start and stop cron jobs: startcronjobs() and stopcronjobs(). These functions can be used outside of a web server as well.","category":"section"},{"location":"tutorial/first_steps/#First-Steps","page":"First Steps","title":"First Steps","text":"In this tutorial, you'll learn about all the core features of Oxygen ia a simple step-by-step approach. This guide will be aimed at beginner/intermediate users and will gradually build upon each other. ","category":"section"},{"location":"tutorial/first_steps/#Setup-your-first-project","page":"First Steps","title":"Setup your first project","text":"Navigate to your projects folder (If you're using and editor like vscode, just open up your project folder\n\ncd /path/to/your/project\n\nOpen open a terminal and start the julia repl with this command\n\njulia\n\nBefore we go any further, lets create a new environment for this project. Press the ] key inside the repl to use Pkg (julia's jult in package manager)  you should see something similar to (v1.7) pkg> in the repl\n\nActivate your current environment \n\npkg> activate .\n\nInstall the latest version of Oxygen and HTTP\n\npkg> add Oxygen HTTP\n\nPress the backspace button to exit the package manager and return to the julia repl\n\nIf everything was done correctly, you should see a Project.toml and Manifest.toml  file created in your project folder\n\nNext lets create our src folder and our main.jl file. Once that's complete, our project  should ook something like this.\n\nproject\n├── src\n│   ├── main.jl\n├── Project.toml\n├── Manifest.toml\n\n\nFor the duration of this guide, we will be working out of the src/main.jl file ","category":"section"},{"location":"tutorial/first_steps/#Creating-your-first-web-server","page":"First Steps","title":"Creating your first web server","text":"Here's an example of what a simple Oxygen server could look like\n\nmodule Main \nusing Oxygen\nusing HTTP\n\n@get \"/greet\" function(req::HTTP.Request)\n    return \"hello world!\"\nend\n\nserve()\nend\n\nStart the webserver with:\n\ninclude(\"src/main.jl\")","category":"section"},{"location":"tutorial/first_steps/#Line-by-line","page":"First Steps","title":"Line by line","text":"using Oxygen\nusing HTTP\n\nHere we pull in the both libraries our api depends on. The @get macro and serve() function come from Oxygen and the HTTP.Request type comes from the HTTP library.\n\nNext we move into the core snippet where we define a route for our api. This route is made up of several components.\n\nhttp method  => from @get macro (it's a GET request)\npath => the endpoint that will get added to our api which is \"/greet\"\nrequest handler => The function that accepts a request and returns a response\n\n@get \"/greet\" function(req::HTTP.Request)\n    return \"hello world!\"\nend\n\nFinally at the bottom of our Main module we have this function to start up our brand new webserver. This function can take a number of keyword arguments such as the host & port, which can be helpful if you don't want to use the default values.\n\nserve()\n\nFor example, you can start your server on port 8000 instead of 8080 which is used by default\n\nserve(port=8000)","category":"section"},{"location":"tutorial/first_steps/#Try-out-your-endpoints","page":"First Steps","title":"Try out your endpoints","text":"You should see the server starting up inside the console.  You should be able to hit http://127.0.0.1:8080/greet inside your browser and see the following:\n\n\"hello world!\"","category":"section"},{"location":"tutorial/first_steps/#Interactive-API-documenation","page":"First Steps","title":"Interactive API documenation","text":"Open your browser to http://127.0.0.1:8080/docs Here you'll see the auto-generated documentation for your api.  This is done internally by generating a JSON object that conforms to the openapi format.  Once generated, you can feed this same schema to libraries like swagger which translate this  into an interactive api for you to explore.","category":"section"}]
}
